[["index.html", "Multi-modal Data Integration CBW Cancer Workshop Multi-modal Data Integration ( June 2021 )", " Multi-modal Data Integration CBW Cancer Workshop Shraddha Pai Sys.Date() Multi-modal Data Integration ( June 2021 ) This book contains lab exercises for Module 10: Multi-modal Data Integration, as part of the Canadian Bioinformatics Workshop Cancer (CAN) Module. You can download course slides here (ADD LINK) We will have two lab exercises learning to build patient classifiers using multi-modal data integration: LAB 1: Gentle introduction: We will build a three-way classifier of tumour subtype using four types of -omic data (gene expression, miRNA, DNA methylation and proteomics). Simple design with a single patient similarity network created from each layer, using Pearson correlation-based similarity. knitr::include_graphics(&quot;images/Lab1_design.jpg&quot;) LAB 2: Pathway features: We will build a binary classifier of tumour subtype using gene expression and clinical data. We will define features at the pathway level for gene expression to identify pathways predictive of outcome, and features using individual clinical variables. For the latter we will tell netDx to use a custom similarity metric of normalized difference. knitr::include_graphics(&quot;images/Lab2_design.jpg&quot;) Were going to use Rstudio to run these labs. Lets go! "],["lab-1-build-3-way-patient-classifier-from-4-data-layers.html", "Lab 1: Build 3-way patient classifier from 4 data layers Intro Prepare data Make rules to convert data into features Build predictor Examine output Conclusion sessionInfo", " Lab 1: Build 3-way patient classifier from 4 data layers Intro In this lab we will build a predictor to classify three different types of breast tumours, two of a luminal subtype (Luminal A and Luminal B), and one of a basal subtype. For this we will use data from the The Cancer Genome Atlas, and will integrate four types of -omic data: gene expression (measured on XXX arrays) DNA methylation (XXX arrays) proteomic measures from XXX, and miRNA sequencing knitr::include_graphics(&quot;images/Lab1_design.jpg&quot;) Figure 1: Lab 2: Predictor design Prepare data In this example, we use curated data from The Cancer Genome Atlas, through the BioConductor curatedTCGAData package. Data for all cancer types profiled in TCGA are available through this package; see tutorial for more info. suppressMessages(library(curatedTCGAData)) Take a look at the available data without downloading any (set dry.run=TRUE): curatedTCGAData(diseaseCode=&quot;BRCA&quot;, assays=&quot;*&quot;,dry.run=TRUE) ## snapshotDate(): 2020-10-27 ## See &#39;?curatedTCGAData&#39; for &#39;diseaseCode&#39; and &#39;assays&#39; inputs ## ah_id title file_size rdataclass rdatadateadded rdatadateremoved ## 1 EH584 BRCA_CNASeq-20160128 0 Mb RaggedExperiment 2017-10-10 &lt;NA&gt; ## 2 EH585 BRCA_CNASNP-20160128 9.8 Mb RaggedExperiment 2017-10-10 &lt;NA&gt; ## 3 EH586 BRCA_CNVSNP-20160128 2.8 Mb RaggedExperiment 2017-10-10 &lt;NA&gt; ## 4 EH588 BRCA_GISTIC_AllByGene-20160128 1.3 Mb SummarizedExperiment 2017-10-10 &lt;NA&gt; ## 5 EH2121 BRCA_GISTIC_Peaks-20160128 0 Mb RangedSummarizedExperiment 2019-01-09 &lt;NA&gt; ## 6 EH589 BRCA_GISTIC_ThresholdedByGene-20160128 0.4 Mb SummarizedExperiment 2017-10-10 &lt;NA&gt; ## 7 EH2122 BRCA_Methylation_methyl27-20160128_assays 63.2 Mb SummarizedExperiment 2019-01-09 &lt;NA&gt; ## 8 EH2123 BRCA_Methylation_methyl27-20160128_se 0.4 Mb SummarizedExperiment 2019-01-09 &lt;NA&gt; ## 9 EH2124 BRCA_Methylation_methyl450-20160128_assays 2613.2 Mb RaggedExperiment 2019-01-09 &lt;NA&gt; ## 10 EH2125 BRCA_Methylation_methyl450-20160128_se 6.1 Mb SummarizedExperiment 2019-01-09 &lt;NA&gt; ## 11 EH593 BRCA_miRNASeqGene-20160128 0.6 Mb SummarizedExperiment 2017-10-10 &lt;NA&gt; ## 12 EH594 BRCA_mRNAArray-20160128 27.3 Mb SummarizedExperiment 2017-10-10 &lt;NA&gt; ## 13 EH595 BRCA_Mutation-20160128 4.5 Mb RaggedExperiment 2017-10-10 &lt;NA&gt; ## 14 EH596 BRCA_RNASeq2GeneNorm-20160128 64.5 Mb SummarizedExperiment 2017-10-10 &lt;NA&gt; ## 15 EH597 BRCA_RNASeqGene-20160128 30 Mb SummarizedExperiment 2017-10-10 &lt;NA&gt; ## 16 EH598 BRCA_RPPAArray-20160128 1.6 Mb SummarizedExperiment 2017-10-10 &lt;NA&gt; Now lets actually download the data, getting just the four layers we need: brca &lt;- suppressMessages(curatedTCGAData(&quot;BRCA&quot;, c(&quot;mRNAArray&quot;,&quot;Methylation_methyl27&quot;, &quot;RPPAArray&quot;,&quot;miRNASeqGene&quot;), dry.run=FALSE)) This call returns a MultiAssayExperiment object. Recall that this is a container for storing multiple assays performed on the same set of samples. See this tutorial to learn more. Lets briefly explore the brca MultiAssayExperiment object. brca ## A MultiAssayExperiment object of 4 listed ## experiments with user-defined names and respective classes. ## Containing an ExperimentList class object of length 4: ## [1] BRCA_miRNASeqGene-20160128: SummarizedExperiment with 1046 rows and 849 columns ## [2] BRCA_mRNAArray-20160128: SummarizedExperiment with 17814 rows and 590 columns ## [3] BRCA_RPPAArray-20160128: SummarizedExperiment with 226 rows and 937 columns ## [4] BRCA_Methylation_methyl27-20160128: SummarizedExperiment with 27578 rows and 343 columns ## Functionality: ## experiments() - obtain the ExperimentList instance ## colData() - the primary/phenotype DataFrame ## sampleMap() - the sample coordination DataFrame ## `$`, `[`, `[[` - extract colData columns, subset, or experiment ## *Format() - convert into a long or wide DataFrame ## assays() - convert ExperimentList to a SimpleList of matrices ## exportClass() - save all data to files assays() returns a list with all -omic data associated with this object. summary(assays(brca)) ## [1] &quot;List object of length 4 with 0 metadata columns&quot; names() shows the datatypes in each slot of assays(): names(assays(brca)) ## [1] &quot;BRCA_miRNASeqGene-20160128&quot; &quot;BRCA_mRNAArray-20160128&quot; &quot;BRCA_RPPAArray-20160128&quot; ## [4] &quot;BRCA_Methylation_methyl27-20160128&quot; So miRNA data is in slot 1, gene expression in slot 2, etc., We can subset the data to see what it looks like. Lets do that for the miRNA data, looking at just the first five measures mir &lt;- assays(brca)[[&quot;BRCA_miRNASeqGene-20160128&quot;]] head(mir[,1:5]) ## TCGA-3C-AAAU-01A-11R-A41G-13 TCGA-3C-AALI-01A-11R-A41G-13 TCGA-3C-AALJ-01A-31R-A41G-13 TCGA-3C-AALK-01A-11R-A41G-13 ## hsa-let-7a-1 95618 49201 75342 57278 ## hsa-let-7a-2 189674 98691 150472 114320 ## hsa-let-7a-3 96815 49035 76206 57540 ## hsa-let-7b 264034 148591 99938 164553 ## hsa-let-7c 3641 5095 5799 18464 ## hsa-let-7d 4333 3263 5658 2114 ## TCGA-4H-AAAK-01A-12R-A41G-13 ## hsa-let-7a-1 67196 ## hsa-let-7a-2 134563 ## hsa-let-7a-3 67607 ## hsa-let-7b 136918 ## hsa-let-7c 20429 ## hsa-let-7d 2162 Sample phenotype data is contained in the colData() slot. Rows contain data for each patient and columns contain metadata measures, such as clinical characteristics: pheno &lt;- colData(brca) colnames(pheno)[1:20] ## [1] &quot;patientID&quot; &quot;years_to_birth&quot; &quot;vital_status&quot; ## [4] &quot;days_to_death&quot; &quot;days_to_last_followup&quot; &quot;tumor_tissue_site&quot; ## [7] &quot;pathologic_stage&quot; &quot;pathology_T_stage&quot; &quot;pathology_N_stage&quot; ## [10] &quot;pathology_M_stage&quot; &quot;gender&quot; &quot;date_of_initial_pathologic_diagnosis&quot; ## [13] &quot;days_to_last_known_alive&quot; &quot;radiation_therapy&quot; &quot;histological_type&quot; ## [16] &quot;number_of_lymph_nodes&quot; &quot;race&quot; &quot;ethnicity&quot; ## [19] &quot;admin.bcr&quot; &quot;admin.day_of_dcc_upload&quot; head(pheno[,1:5]) ## DataFrame with 6 rows and 5 columns ## patientID years_to_birth vital_status days_to_death days_to_last_followup ## &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## TCGA-A1-A0SB TCGA-A1-A0SB 70 0 NA 259 ## TCGA-A1-A0SD TCGA-A1-A0SD 59 0 NA 437 ## TCGA-A1-A0SE TCGA-A1-A0SE 56 0 NA 1321 ## TCGA-A1-A0SF TCGA-A1-A0SF 54 0 NA 1463 ## TCGA-A1-A0SG TCGA-A1-A0SG 61 0 NA 434 ## TCGA-A1-A0SH TCGA-A1-A0SH 39 0 NA 1437 This next code block prepares the TCGA data. This includes: removing duplicate samples reformatting patient IDs (e.g.removing spaces and hyphens) required: creating an ID column in colData(brca), which contains unique patient IDs required: creating a STATUS column in colData(brca) which contains the patient labels (i.e what we want netDx to classify). In practice you would prepare the dataset once and save it to file, then separately load it before running netDx; i.e.decouple data processing and running the predictor. The data processing code has been moved into a supporting file, prepare_data.R. You can explore it after the lab to see how some things are achieved (e.g.removing duplicate samples). For now, lets just run it. source(&quot;prepare_data.R&quot;) brca &lt;- prepareDataForCBW(brca) ## harmonizing input: ## removing 42 sampleMap rows with &#39;colname&#39; not in colnames of experiments ## harmonizing input: ## removing 59 sampleMap rows with &#39;colname&#39; not in colnames of experiments ## harmonizing input: ## removing 19 sampleMap rows with &#39;colname&#39; not in colnames of experiments ## harmonizing input: ## removing 26 sampleMap rows with &#39;colname&#39; not in colnames of experiments Notice that we now have ID and STATUS columns in the sample metadata table. Note: These columns are required by netDx. pheno &lt;- colData(brca) head(pheno[,c(&quot;ID&quot;,&quot;STATUS&quot;)]) ## DataFrame with 6 rows and 2 columns ## ID STATUS ## &lt;character&gt; &lt;character&gt; ## TCGA-A1-A0SD TCGA-A1-A0SD Luminal.A ## TCGA-A1-A0SE TCGA-A1-A0SE Luminal.A ## TCGA-A1-A0SH TCGA-A1-A0SH Luminal.A ## TCGA-A1-A0SJ TCGA-A1-A0SJ Luminal.A ## TCGA-A1-A0SK TCGA-A1-A0SK Basal.like ## TCGA-A1-A0SM TCGA-A1-A0SM Luminal.B table(pheno$STATUS,useNA=&quot;always&quot;) # good practice: useNA=&quot;always&quot; shows missing values ## ## Basal.like Luminal.A Luminal.B &lt;NA&gt; ## 98 231 127 0 Make rules to convert data into features Now lets set up the data for input to netDx. netDx allows the user to define how data is converted into patient similarity networks (or PSNs), which are the features that go into the model. This is done specifically by telling the model how to: group different types of data and define similarity for each of these (e.g.Pearson correlation, normalized difference, etc.,). The relevant input parameters are: groupList: sets of input data that would correspond to individual networks (e.g.genes grouped into pathways) makeNets(): an R function telling netDx what similarity metric to use for each data layer Lets start by loading the netDx package. suppressWarnings(suppressMessages(require(netDx))) Lets set up each of the input arguments one by one. groupList What is this: groupList tells netDx how to group measures within a layer, to generate a PSN. Measures could be individual genes, proteins, CpG bases (in DNA methylation data), clinical variables, etc., In this simple example we just create a single PSN for each datatype, containing all measures from that datatype. expr &lt;- assays(brca) groupList &lt;- list() for (k in 1:length(expr)) { # loop over all layers cur &lt;- expr[[k]]; nm &lt;- names(expr)[k] # all measures from this layer go into our single PSN groupList[[nm]] &lt;- list(nm=rownames(cur)) # assign same layer name as in input data names(groupList[[nm]])[1] &lt;- nm; } Notice that groupList is a two tiered list, or list-of-lists. The first tier is for each data layers, with names matching those in assays(brca). The second tier contains all the PSNs we want to make for that layer. In this lab exercise we create only one PSN per data layer, using all the measures from an -omic assay. e.g.One PSN based on similarity across entire transcriptome, one for methylome, etc.,). So in this lab exercise, the inner tier simply contains one entry, with all measures for the given layer. This design will get more interesting in Lab 2, when we create pathway-level features. Lets take a look at groupList. Here is the first tier: summary(groupList) ## Length Class Mode ## BRCA_miRNASeqGene-20160128 1 -none- list ## BRCA_mRNAArray-20160128 1 -none- list ## BRCA_RPPAArray-20160128 1 -none- list ## BRCA_Methylation_methyl27-20160128 1 -none- list And the second tier: names(groupList[[&quot;BRCA_mRNAArray-20160128&quot;]]) ## [1] &quot;BRCA_mRNAArray-20160128&quot; length(groupList[[&quot;BRCA_mRNAArray-20160128&quot;]][[1]]) ## [1] 17814 head(groupList[[&quot;BRCA_mRNAArray-20160128&quot;]][[1]]) ## [1] &quot;ELMO2&quot; &quot;CREB3L1&quot; &quot;RPS11&quot; &quot;PNMA1&quot; &quot;MMP2&quot; &quot;C10orf90&quot; Define patient similarity for each network The makeNets function tells the predictor how to create networks from provided input data. This function requires dataList,groupList, and netDir as input variables. The residual ... parameter is to pass additional variables to makePSN_NamedMatrix(), notably numCores (number of parallel jobs). netDx requires that this function have: dataList,groupList, and netDir as input variables. The residual ... parameter is to pass additional variables to makePSN_NamedMatrix(), notably number of cores for parallel processing (numCores). makeNets &lt;- function(dataList, groupList, netDir,...) { netList &lt;- c() # initialize before is.null() check layerNames &lt;- c(&quot;BRCA_miRNASeqGene-20160128&quot;, &quot;BRCA_mRNAArray-20160128&quot;, &quot;BRCA_RPPAArray-20160128&quot;, &quot;BRCA_Methylation_methyl27-20160128&quot;) for (nm in layerNames){ ## for each layer if (!is.null(groupList[[nm]])){ ## must check for null for each layer netList_cur &lt;- makePSN_NamedMatrix( dataList[[nm]], rownames(dataList[[nm]]), ## names of measures (e.g. genes, CpGs) groupList[[nm]], ## how to group measures in that layer netDir, ## leave this as-is, netDx will figure out where this is. verbose=FALSE, writeProfiles=TRUE, ## use Pearson correlation-based similarity ... ) netList &lt;- c(netList,netList_cur) ## just leave this in } } return(unlist(netList)) ## just leave this in } Note: While netDx provides a high degree of flexibility in achieving your design of choice, it is up to the user to ensure that the design, i.e.the similarity metric and variable groupings, is appropriate for your application. Domain knowledge is almost likely required for good design. Build predictor Finally we call the function that runs the netDx predictor. We provide: patient data (dataList) grouping rules (groupList) function to create PSN from data, includes choice of similarity metric (makeNetFunc) number of train/test splits over which to collect feature scores and average performance: numSplits, maximum score for features in one round of feature selection (featScoreMax, set to 10) threshold to call feature-selected networks for each train/test split (featSelCutoff); only features scoring this value or higher will be used to classify test patients, number of cores to use for parallel processing (numCores). The call below runs 2 train/test splits, to be able to run fast. Within each split, it: splits data into train/test using the default split of 80:20 (trainProp=0.8) score networks between 0 to 2 (i.e.featScoreMax=2L) uses networks that score &gt;=1 out of 2 (featSelCutoff=1L) to classify test samples for that split. These are unrealistically low values set so the example will run fast. In practice a good starting point is featScoreMax=10, featSelCutoff=9 and numSplits=100, but these parameters depend on the sample sizes in the dataset and heterogeneity of the samples. set.seed(42) # make results reproducible outDir &lt;- paste(tempdir(),randAlphanumString(), &quot;pred_output&quot;,sep=getFileSep()) if (file.exists(outDir)) unlink(outDir,recursive=TRUE) t0 &lt;- Sys.time() model &lt;- suppressMessages(buildPredictor( dataList=brca, ## your data groupList=groupList, ## grouping strategy makeNetFunc=makeNets, ## function to build PSNs outDir=outDir, ## output directory trainProp=0.8, ## pct of samples to use to train model in ## each split numSplits=2L, ## number of train/test splits featSelCutoff=1L, ## threshold for calling something ## feature-selected featScoreMax=2L, ## max score for feature selection numCores=8L, ## set higher for parallelizing debugMode=FALSE, keepAllData=FALSE, ## set to TRUE for debugging or low-level files used by the predictor logging=&quot;none&quot; )) t1 &lt;- Sys.time() print(t1-t0) ## Time difference of 15.88341 mins Examine output The results are stored in the list object returned by the buildPredictor() call. This list contains: inputNets: all input networks that the model started with. Split&lt;i&gt;: results for each train-test split (list) predictions: real and predicted labels for test patients accuracy: percent accuracy of predictions featureScores: feature scores for each label (list with g entries, where g is number of patient labels). Each entry contains the feature selection scores for the corresponding label. featureSelected: features passing feature selection in a split (list of length g, with one entry per label) summary(model) ## Length Class Mode ## inputNets 8 -none- character ## Split1 4 -none- list ## Split2 4 -none- list summary(model$Split1) ## Length Class Mode ## featureScores 3 -none- list ## featureSelected 3 -none- list ## predictions 2692 data.frame list ## accuracy 1 -none- numeric Get model results Now we get model output, including performance for various train/test splits and consistently high-scoring features. Weve actually generated results using more real-world parameters, including 10 train/test splits and a greater dynamic range for feature scores (featScoreMax=10L and featSelCutoff=9L). Lets load those for a better experience exploring results: outFile &lt;- sprintf(&quot;%s/CBW_Lab1_full.rda&quot;,tempdir()) download.file(&quot;https://github.com/RealPaiLab/CBW_CAN_DataIntegration_2021/raw/master/supporting_files/Lab1_files/Lab1_10splits.rda&quot;, destfile=outFile) lnames &lt;- load(outFile) helper.R contains convenience functions to do this, which will be integrated into upcoming versions of netDx. In the function below, we define top-scoring features as those which score at least 2 in at least half of the train/test splits source(&quot;helper.R&quot;) results &lt;- getResults(brca,model_full,featureSelCutoff=9L, featureSelPct=0.9) ## Detected 10 splits and 3 classes ## * Compiling feature scores and calling selected features results contains performance, selectedFeatures for each patient label, and the table of feature scores. summary(results) ## Length Class Mode ## selectedFeatures 3 -none- list ## featureScores 3 -none- list ## performance 2 -none- list Look at the performance: results$performance ## $meanAccuracy ## [1] 0.7610799 ## ## $splitAccuracy ## [1] 0.7741935 0.7204301 0.7500000 0.7419355 0.7419355 0.8279570 0.7826087 0.8152174 0.7065217 0.7500000 Look at feature scores for all labels, across all train-test splits: results$featureScores ## $Luminal.A ## Feature Split1 Split2 Split3 Split4 Split5 Split6 Split7 Split8 Split9 Split10 ## 1 BRCA_Methylation_methyl27-20160128 7 9 9 10 9 8 8 7 10 10 ## 2 BRCA_RPPAArray-20160128 10 10 10 10 10 10 10 10 10 10 ## 3 BRCA_mRNAArray-20160128 10 10 10 10 10 10 10 10 10 10 ## 4 BRCA_miRNASeqGene-20160128 9 5 6 10 5 6 6 9 10 7 ## ## $Basal.like ## Feature Split1 Split2 Split3 Split4 Split5 Split6 Split7 Split8 Split9 Split10 ## 1 BRCA_Methylation_methyl27-20160128 10 10 10 10 10 10 10 10 10 10 ## 2 BRCA_RPPAArray-20160128 10 10 10 10 10 10 10 10 10 10 ## 3 BRCA_mRNAArray-20160128 10 10 10 10 10 10 10 10 10 10 ## 4 BRCA_miRNASeqGene-20160128 NA 4 NA 1 4 1 NA NA 7 2 ## ## $Luminal.B ## Feature Split1 Split2 Split3 Split4 Split5 Split6 Split7 Split8 Split9 Split10 ## 1 BRCA_Methylation_methyl27-20160128 10 10 10 10 10 10 10 10 10 10 ## 2 BRCA_RPPAArray-20160128 10 10 10 10 10 10 10 10 10 10 ## 3 BRCA_mRNAArray-20160128 10 10 10 10 10 10 10 10 10 10 And here are selected features, which are those scoring 2 out of 2 in at least half of the splits. This threshold is simply for illustration. In practice we would run at least 10 train/test splits (ideally 100+), and look for features that score 7+ out of 10 in &gt;70% splits. results$selectedFeatures ## $Luminal.A ## [1] &quot;BRCA_RPPAArray-20160128&quot; &quot;BRCA_mRNAArray-20160128&quot; ## ## $Basal.like ## [1] &quot;BRCA_Methylation_methyl27-20160128&quot; &quot;BRCA_RPPAArray-20160128&quot; &quot;BRCA_mRNAArray-20160128&quot; ## ## $Luminal.B ## [1] &quot;BRCA_Methylation_methyl27-20160128&quot; &quot;BRCA_RPPAArray-20160128&quot; &quot;BRCA_mRNAArray-20160128&quot; We finally get the integrated PSN and visualize it using a tSNE plot: psnFile &lt;- sprintf(&quot;%s/psn.rda&quot;,tempdir()) download.file(&quot;https://github.com/RealPaiLab/CBW_CAN_DataIntegration_2021/raw/master/supporting_files/Lab1_files/Lab1_PSN.rda&quot;, destfile=outFile) load(outFile) #psn &lt;- getPSN(brca,groupList_full,makeNets_full,results$selectedFeatures) tsne &lt;- tSNEPlotter( psn$patientSimNetwork_unpruned, colData(brca) ) ## * Making symmetric matrix ## * Running tSNE ## * Plotting Conclusion Congratulations! You have successfully classified three types of tumours by integrating four different -omic layers (transcriptomic, methylomic,proteomic and miRNA). We see there s Best practices side note: We end this tutorial with a call to sessionInfo() which prints the complete environment information for your R session. This is standard output that should be reported to R package managers when you write in with a question, particularly if reporting an error or bug. Sometimes a particular underlying dependency package may be the cause of an error, or you may need to upgrade to a newer version of the package. By including this info in an email, you will allow the other person to better solve your issue. sessionInfo sessionInfo() ## R version 4.0.5 (2021-03-31) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.2 LTS ## ## Matrix products: default ## BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so ## ## locale: ## [1] LC_CTYPE=C LC_NUMERIC=C LC_TIME=C LC_COLLATE=C LC_MONETARY=C ## [6] LC_MESSAGES=C LC_PAPER=en_US.UTF-8 LC_NAME=C LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] parallel stats4 stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] plotrix_3.8-1 ggplot2_3.3.3 Rtsne_0.15 netDx_1.2.3 ## [5] bigmemory_4.5.36 rhdf5_2.34.0 curatedTCGAData_1.12.1 MultiAssayExperiment_1.16.0 ## [9] SummarizedExperiment_1.20.0 Biobase_2.50.0 GenomicRanges_1.42.0 GenomeInfoDb_1.26.7 ## [13] IRanges_2.24.1 S4Vectors_0.28.1 BiocGenerics_0.36.1 MatrixGenerics_1.2.1 ## [17] matrixStats_0.58.0 ## ## loaded via a namespace (and not attached): ## [1] utf8_1.2.1 R.utils_2.10.1 tidyselect_1.1.1 RSQLite_2.2.7 ## [5] AnnotationDbi_1.52.0 grid_4.0.5 combinat_0.0-8 BiocParallel_1.24.1 ## [9] RNeXML_2.4.5 munsell_0.5.0 codetools_0.2-18 withr_2.4.2 ## [13] colorspace_2.0-1 highr_0.9 knitr_1.33 uuid_0.1-4 ## [17] zinbwave_1.12.0 rstudioapi_0.13 SingleCellExperiment_1.12.0 ROCR_1.0-11 ## [21] NMF_0.23.0 labeling_0.4.2 GenomeInfoDbData_1.2.4 farver_2.1.0 ## [25] bit64_4.0.5 vctrs_0.3.8 generics_0.1.0 xfun_0.23 ## [29] BiocFileCache_1.14.0 R6_2.5.0 doParallel_1.0.16 ggbeeswarm_0.6.0 ## [33] netSmooth_1.10.0 rsvd_1.0.5 RJSONIO_1.3-1.4 locfit_1.5-9.4 ## [37] bitops_1.0-7 rhdf5filters_1.2.1 cachem_1.0.5 DelayedArray_0.16.3 ## [41] assertthat_0.2.1 promises_1.2.0.1 scales_1.1.1 beeswarm_0.3.1 ## [45] gtable_0.3.0 phylobase_0.8.10 beachmat_2.6.4 rlang_0.4.11 ## [49] genefilter_1.72.1 splines_4.0.5 lazyeval_0.2.2 BiocManager_1.30.15 ## [53] yaml_2.2.1 reshape2_1.4.4 httpuv_1.6.1 tools_4.0.5 ## [57] bookdown_0.22 gridBase_0.4-7 ellipsis_0.3.2 jquerylib_0.1.4 ## [61] RColorBrewer_1.1-2 Rcpp_1.0.6 plyr_1.8.6 sparseMatrixStats_1.2.1 ## [65] progress_1.2.2 zlibbioc_1.36.0 purrr_0.3.4 RCurl_1.98-1.3 ## [69] prettyunits_1.1.1 viridis_0.6.1 cluster_2.1.1 tinytex_0.31 ## [73] magrittr_2.0.1 data.table_1.14.0 RSpectra_0.16-0 hms_1.1.0 ## [77] mime_0.10 evaluate_0.14 xtable_1.8-4 XML_3.99-0.6 ## [81] jpeg_0.1-8.1 gridExtra_2.3 shape_1.4.6 compiler_4.0.5 ## [85] scater_1.18.6 tibble_3.1.2 RCy3_2.10.2 crayon_1.4.1 ## [89] entropy_1.3.0 R.oo_1.24.0 htmltools_0.5.1.1 later_1.2.0 ## [93] tidyr_1.1.3 howmany_0.3-1 DBI_1.1.1 ExperimentHub_1.16.1 ## [97] dbplyr_2.1.1 MASS_7.3-53.1 rappdirs_0.3.3 Matrix_1.3-2 ## [101] ade4_1.7-16 R.methodsS3_1.8.1 igraph_1.2.6 pkgconfig_2.0.3 ## [105] bigmemory.sri_0.1.3 rncl_0.8.4 registry_0.5-1 locfdr_1.1-8 ## [109] scuttle_1.0.4 xml2_1.3.2 foreach_1.5.1 annotate_1.68.0 ## [113] vipor_0.4.5 bslib_0.2.5.1 rngtools_1.5 pkgmaker_0.32.2 ## [117] XVector_0.30.0 stringr_1.4.0 digest_0.6.27 pracma_2.3.3 ## [121] graph_1.68.0 softImpute_1.4-1 rmarkdown_2.8 edgeR_3.32.1 ## [125] DelayedMatrixStats_1.12.3 curl_4.3.1 kernlab_0.9-29 shiny_1.6.0 ## [129] lifecycle_1.0.0 nlme_3.1-152 jsonlite_1.7.2 clusterExperiment_2.10.1 ## [133] Rhdf5lib_1.12.1 BiocNeighbors_1.8.2 viridisLite_0.4.0 limma_3.46.0 ## [137] fansi_0.4.2 pillar_1.6.1 lattice_0.20-41 fastmap_1.1.0 ## [141] httr_1.4.2 survival_3.2-10 interactiveDisplayBase_1.28.0 glue_1.4.2 ## [145] png_0.1-7 iterators_1.0.13 BiocVersion_3.12.0 glmnet_4.1-1 ## [149] bit_4.0.4 stringi_1.6.2 sass_0.4.0 HDF5Array_1.18.1 ## [153] blob_1.2.1 BiocSingular_1.6.0 AnnotationHub_2.22.1 memoise_2.0.0 ## [157] dplyr_1.0.6 irlba_2.3.3 ape_5.5 "],["lab-2-pathway-level-features.html", "Lab 2: Pathway-level features Setup Make rules to create PSNs Build predictor Examine output Visualize top pathways in Cytoscape sessionInfo", " Lab 2: Pathway-level features In this example, we will learn how to: Use custom similarity metrics Group variables into biologically-meaningful units such as pathways, for improved interpretability Here, we will again use breast cancer samples, and discriminate between Luminal A, Luminal B and basal-like tumours. We will limit ourselves to clinical data and gene expression data but will make the following design changes: Clinical variables: A feature (or patient similarity network;PSN) will be defined at the level of selected variables (e.g.age); we will define similarity as normalized difference. Gene expression: Features will be defined at the level of pathways; i.e.each feature groups only those genes corresponding to the pathway. Similarity is defined as pairwise Pearson correlation. Figure 2: Lab 2: Predictor design Setup Lets fetch the BRCA data using curatedTCGAData again, this time only the gene expression data. Remember, the clinical data we automatically get in the colData() slot returned. suppressMessages(library(curatedTCGAData)) brca &lt;- suppressMessages( curatedTCGAData( &quot;BRCA&quot;,c(&quot;mRNAArray&quot;), dry.run=FALSE) ) Lets look at the data. Notice that we now only have one -omic assay, gene expression measures from microarrays. brca ## A MultiAssayExperiment object of 1 listed ## experiment with a user-defined name and respective class. ## Containing an ExperimentList class object of length 1: ## [1] BRCA_mRNAArray-20160128: SummarizedExperiment with 17814 rows and 590 columns ## Functionality: ## experiments() - obtain the ExperimentList instance ## colData() - the primary/phenotype DataFrame ## sampleMap() - the sample coordination DataFrame ## `$`, `[`, `[[` - extract colData columns, subset, or experiment ## *Format() - convert into a long or wide DataFrame ## assays() - convert ExperimentList to a SimpleList of matrices ## exportClass() - save all data to files As before, we prepare the data. I highly recommend separating the script that prepares the data from the one running the predictor for improved management, readability and debuggability. source(&quot;prepare_data.R&quot;) brca &lt;- prepareDataForCBW(brca, setBinary=TRUE) ## harmonizing input: ## removing 44 sampleMap rows with &#39;colname&#39; not in colnames of experiments Make rules to create PSNs Load the netDx package and initialize the groupList object, where we will store our grouping rules. Recall that groupList is a list-of-lists, with the top tier containing data layer names, and that the layer names must match names(assays(brca)) or whatever your MultiAssayExperiment object is called. suppressWarnings(suppressMessages(require(netDx))) groupList &lt;- list() RNA: Pathway features Lets group genes into pathway-level features, i.e.instead of one PSN for transcriptomic data, we create one PSN for each pathway. So if you had a pathway set with 2,000 curated pathways, this would generate 2,000 input PSN. NOTE: This design changes model-building time to several hours, so avoid large gene sets (e.g.the full set of ~44,000 Gene Ontology terms, or even ~29,000 GO Biological Process terms). A reasonable start is a compilation of pathways from all curated pathway databases, as in below. Whicever list you use can be pruned by constraining the min/max number of genes in a set, but the size is something to keep in mind. There are two ways of providing pathway data to netDx: 1. You can download a compilation of pathways from curated databases using the fetchPathwayDefinitions() function in netDx, like so: x &lt;- fetchPathwayDefinitions(&quot;March&quot;,2021) ## Fetching http://download.baderlab.org/EM_Genesets/March_01_2021/Human/symbol/Human_AllPathways_March_01_2021_symbol.gmt x ## BFC2 ## &quot;~/.cache/netDx/20e22fee64ce_Human_AllPathways_March_01_2021_symbol.gmt&quot; The above pathway set was downloaded from download.baderlab.org/EM_Genesets, which is a good resource for routinely-updated curated pathway definitions. Pathways are compiled from Reactome, Panther, NCI, MSigDB, etc., [REF], and data is contained in GMT format, a common format to represent gene-sets, such as pathways. You can see from the value of x that the file isnt downloaded to our working directory, but rather is stored in a BioConductor-specific location for files (file cache), using the BiocFileCache class. This way if we rerun the script, BioConductor will only download the file again if it has changed since our last download. Here is an example of the GMT format: Figure 3: Lab 2: Predictor design We then use readPathways() to read the pathways into a list format to provide the predictor with. So the full call looks like this: pathList &lt;- readPathways(fetchPathwayDefinitions(&quot;March&quot;,2021)) ## --------------------------------------- ## Fetching http://download.baderlab.org/EM_Genesets/March_01_2021/Human/symbol/Human_AllPathways_March_01_2021_symbol.gmt ## File: 20e22fee64ce_Human_AllPathways_March_01_2021_symbol.gmt ## Warning in scan(f, what = &quot;character&quot;, nlines = 1, quiet = TRUE, sep = &quot;\\t&quot;): EOF within quoted string ## Read 1123 pathways in total, internal list has 1110 entries ## FILTER: sets with num genes in [10, 200] ## =&gt; 341 pathways excluded ## =&gt; 769 left head(pathList) ## $STEARATE_BIOSYNTHESIS_I__ANIMALS_ ## [1] &quot;ELOVL1&quot; &quot;ACOT7&quot; &quot;ACSL1&quot; &quot;ACSL5&quot; &quot;ELOVL6&quot; &quot;ACSL4&quot; &quot;ACSL3&quot; &quot;ACOT2&quot; &quot;ACOT1&quot; &quot;ACSBG1&quot; &quot;ACSBG2&quot; &quot;SLC27A2&quot; &quot;ACOT4&quot; ## ## $SUPERPATHWAY_OF_INOSITOL_PHOSPHATE_COMPOUNDS ## [1] &quot;PI4K2B&quot; &quot;MTMR14&quot; &quot;INPPL1&quot; &quot;PTEN&quot; &quot;PIK3CD&quot; &quot;PIK3C2G&quot; &quot;PIK3CB&quot; &quot;PIK3C2A&quot; &quot;PIK3CG&quot; &quot;PIK3C2B&quot; &quot;PIP4P2&quot; &quot;PIP4P1&quot; &quot;PLCZ1&quot; ## [14] &quot;PPIP5K1&quot; &quot;PPIP5K2&quot; &quot;PIP5KL1&quot; &quot;PLCE1&quot; &quot;PIP4K2A&quot; &quot;PIP4K2B&quot; &quot;PIP4K2C&quot; &quot;SACM1L&quot; &quot;ITPK1&quot; &quot;IPMK&quot; &quot;OCRL&quot; &quot;ITPKB&quot; &quot;ITPKC&quot; ## [27] &quot;MINPP1&quot; &quot;PLCB3&quot; &quot;PLCB4&quot; &quot;PIK3CA&quot; &quot;ITPKA&quot; &quot;PIK3C3&quot; &quot;PLCB1&quot; &quot;PLCB2&quot; &quot;PI4K2A&quot; &quot;IPPK&quot; &quot;MTMR3&quot; &quot;PIK3R4&quot; &quot;PIK3R3&quot; ## [40] &quot;PIK3R2&quot; &quot;PIK3R1&quot; &quot;PIK3R6&quot; &quot;PIK3R5&quot; &quot;INPP5B&quot; &quot;INPP5A&quot; &quot;INPP5D&quot; &quot;PLCG2&quot; &quot;INPP5J&quot; &quot;PIP5K1A&quot; &quot;INPP5K&quot; &quot;PIP5K1B&quot; &quot;PIP5K1C&quot; ## [53] &quot;PLCG1&quot; &quot;CDIPT&quot; &quot;IP6K1&quot; &quot;IP6K3&quot; &quot;IP6K2&quot; &quot;SYNJ2&quot; &quot;FIG4&quot; &quot;PIKFYVE&quot; &quot;SYNJ1&quot; &quot;PI4KA&quot; &quot;PLCH1&quot; &quot;PI4KB&quot; &quot;PLCH2&quot; ## [66] &quot;PLCD3&quot; &quot;PLCD4&quot; &quot;PLCD1&quot; ## ## $PUTRESCINE_DEGRADATION_III ## [1] &quot;ALDH3A2&quot; &quot;ALDH3B2&quot; &quot;ALDH3A1&quot; &quot;ALDH1B1&quot; &quot;MAOB&quot; &quot;ALDH2&quot; &quot;MAOA&quot; &quot;ALDH3B1&quot; &quot;SAT2&quot; &quot;SAT1&quot; ## ## $TRYPTOPHAN_DEGRADATION_III__EUKARYOTIC_ ## [1] &quot;ACAT1&quot; &quot;HADHB&quot; &quot;GCDH&quot; &quot;TDO2&quot; &quot;KYNU&quot; &quot;HAAO&quot; &quot;AFMID&quot; &quot;KMO&quot; &quot;ACAA1&quot; &quot;ACAT2&quot; &quot;ACMSD&quot; ## ## $MEVALONATE_PATHWAY_I ## [1] &quot;ACAT1&quot; &quot;IDI1&quot; &quot;MVK&quot; &quot;HMGCS1&quot; &quot;IDI2&quot; &quot;HADHB&quot; &quot;PMVK&quot; &quot;MVD&quot; &quot;HMGCR&quot; &quot;HMGCS2&quot; &quot;ACAA1&quot; &quot;ACAT2&quot; ## ## $`D-_I_MYO__I_-INOSITOL-5-PHOSPHATE_METABOLISM` ## [1] &quot;PLCG1&quot; &quot;PLCB3&quot; &quot;PLCB4&quot; &quot;PLCH1&quot; &quot;PLCH2&quot; &quot;PLCB1&quot; &quot;MTMR14&quot; &quot;PLCD3&quot; &quot;PLCB2&quot; &quot;PLCD4&quot; &quot;PLCD1&quot; &quot;MTMR3&quot; &quot;PIP4P2&quot; ## [14] &quot;PIP4P1&quot; &quot;PLCZ1&quot; &quot;PLCG2&quot; &quot;PLCE1&quot; &quot;PIP4K2A&quot; &quot;PIP4K2C&quot; Alternatively, you can also provide a custom pathway set to netDx by reading in a GMT file, using the readPathways() function. In this example, Ive downloaded a geneset of pathways often dysregulated in cancer, set C6 from MSigDB (REF): gmtFile &lt;- sprintf(&quot;%s2/cancer_pathways.gmt&quot;,tempdir()) if (!file.exists(sprintf(&quot;%s2&quot;,tempdir()))) dir.create(sprintf(&quot;%s2&quot;,tempdir())) download.file(&quot;https://raw.githubusercontent.com/RealPaiLab/CBW_CAN_DataIntegration_2021/master/supporting_files/c6.all.v7.4.symbols.gmt&quot;,gmtFile) x &lt;- readPathways(gmtFile) ## --------------------------------------- ## File: cancer_pathways.gmt ## Read 189 pathways in total, internal list has 189 entries ## FILTER: sets with num genes in [10, 200] ## =&gt; 14 pathways excluded ## =&gt; 175 left x[1:3] ## $GLI1_UP.V1_DN ## [1] &quot;CACUL1&quot; &quot;CCNL2&quot; &quot;YIPF1&quot; &quot;GTDC1&quot; &quot;OPN3&quot; &quot;SLC22A1&quot; &quot;RNF10&quot; &quot;RUNX1&quot; &quot;SEPTIN9&quot; &quot;CD2AP&quot; &quot;ACSL6&quot; &quot;ZMYND11&quot; &quot;FOLR1&quot; ## [14] &quot;PPIL1&quot; &quot;ESYT1&quot; &quot;BTBD16&quot; &quot;SPECC1&quot; ## ## $GLI1_UP.V1_UP ## [1] &quot;IGFBP6&quot; &quot;CCND2&quot; &quot;PTH1R&quot; &quot;TXNDC12&quot; &quot;M6PR&quot; &quot;PPT2&quot; &quot;STAU1&quot; &quot;JCHAIN&quot; &quot;TMOD3&quot; &quot;SAR1A&quot; &quot;ZBTB16&quot; &quot;YBX1&quot; &quot;SGTA&quot; ## [14] &quot;WEE1&quot; &quot;TRIM23&quot; &quot;BMERB1&quot; &quot;NPHP1&quot; &quot;IFT74&quot; &quot;PRKD3&quot; &quot;PLPP6&quot; &quot;FEM1A&quot; &quot;LMO7&quot; &quot;C7orf50&quot; &quot;ZC3H18&quot; ## ## $GCNP_SHH_UP_EARLY.V1_DN ## [1] &quot;SRRM2&quot; &quot;KIAA1217&quot; &quot;DEFA1&quot; &quot;DLK1&quot; &quot;PITX2&quot; &quot;CCL2&quot; &quot;UPK3B&quot; &quot;SEZ6&quot; &quot;TAF15&quot; &quot;EMP1&quot; &quot;SH3BGR&quot; &quot;CCR2&quot; ## [13] &quot;VAV1&quot; &quot;LGALS9&quot; &quot;WIPF1&quot; &quot;LYST&quot; &quot;RRAGD&quot; &quot;CPT1A&quot; &quot;FAM241A&quot; &quot;MAN2B1&quot; &quot;WWC2&quot; &quot;TXLNG&quot; &quot;CNGA2&quot; &quot;NPPB&quot; ## [25] &quot;MYO5B&quot; &quot;XIAP&quot; &quot;HOXB9&quot; &quot;TASOR&quot; &quot;PEX7&quot; &quot;SOX18&quot; &quot;CCRL2&quot; &quot;NR6A1&quot; &quot;CITED2&quot; &quot;LTBP3&quot; &quot;EEPD1&quot; &quot;SIM1&quot; ## [37] &quot;CRABP2&quot; &quot;PPFIBP2&quot; &quot;CYBA&quot; &quot;RAMP1&quot; &quot;TM4SF1&quot; &quot;LIN9&quot; &quot;ASPH&quot; &quot;UBTF&quot; &quot;PIGT&quot; &quot;EOMES&quot; &quot;GBP7&quot; &quot;MERTK&quot; ## [49] &quot;MAP3K12&quot; &quot;IL1R1&quot; &quot;HAS2&quot; &quot;SLC43A3&quot; &quot;CBX1&quot; &quot;GLB1L&quot; &quot;PHLDB2&quot; &quot;GPR19&quot; &quot;GUSB&quot; &quot;CRYGS&quot; &quot;DBP&quot; &quot;VPS54&quot; ## [61] &quot;FRMD5&quot; &quot;DCAF8&quot; &quot;BTD&quot; &quot;ADCY9&quot; &quot;SIX4&quot; &quot;PLA2G10&quot; &quot;SLC6A4&quot; &quot;GCSAM&quot; &quot;CBFA2T3&quot; &quot;GABRA1&quot; &quot;S100A9&quot; &quot;LAT2&quot; ## [73] &quot;SMYD5&quot; &quot;MX2&quot; &quot;AKR1C1&quot; &quot;PLK2&quot; &quot;PDE1B&quot; &quot;ID2&quot; &quot;HOXB3&quot; &quot;GAPDHS&quot; &quot;IER2&quot; &quot;DDB1&quot; &quot;ADAM7&quot; &quot;ETS1&quot; ## [85] &quot;CDK5RAP3&quot; &quot;POLD4&quot; &quot;ITGA4&quot; &quot;FOXA1&quot; &quot;PEPD&quot; &quot;AMOTL2&quot; &quot;CALCR&quot; &quot;BPIFB1&quot; &quot;MAF&quot; &quot;EGR1&quot; &quot;CYP27B1&quot; &quot;URI1&quot; ## [97] &quot;HTRA3&quot; &quot;LCP1&quot; &quot;ACSS1&quot; &quot;SETDB1&quot; &quot;BTC&quot; &quot;NOTCH1&quot; &quot;NR5A2&quot; &quot;LRRC57&quot; &quot;TM2D1&quot; &quot;RABAC1&quot; &quot;DPPA4&quot; &quot;CNN1&quot; ## [109] &quot;JPH3&quot; &quot;MAP4K4&quot; &quot;CD38&quot; &quot;SLC22A6&quot; &quot;MIPOL1&quot; &quot;NLRX1&quot; &quot;GDF3&quot; &quot;ZNF436&quot; &quot;TIRAP&quot; &quot;CFB&quot; &quot;MST1R&quot; &quot;NUB1&quot; ## [121] &quot;H2BC21&quot; &quot;IFNG&quot; &quot;UROS&quot; &quot;POPDC3&quot; &quot;ERO1B&quot; &quot;GRIN1&quot; &quot;PPY&quot; &quot;HES1&quot; &quot;UIMC1&quot; &quot;CAMLG&quot; &quot;LRRC23&quot; &quot;SLC7A3&quot; ## [133] &quot;C4BPA&quot; &quot;PPP2R3C&quot; &quot;CDK5&quot; &quot;MGP&quot; &quot;STS&quot; &quot;PCBD2&quot; &quot;IRF3&quot; &quot;RAG2&quot; &quot;GABRD&quot; &quot;ANKRD44&quot; &quot;TERF2IP&quot; &quot;CCL27&quot; ## [145] &quot;LCLAT1&quot; &quot;MIIP&quot; &quot;TMPO&quot; &quot;AGTR2&quot; &quot;ELMOD3&quot; &quot;GNA14&quot; &quot;JAM3&quot; &quot;RSPO2&quot; &quot;CRYBG1&quot; &quot;PTGER3&quot; &quot;LSR&quot; &quot;NSUN3&quot; ## [157] &quot;MAP2K1&quot; &quot;TMEM160&quot; &quot;ZNF518B&quot; &quot;NR4A2&quot; &quot;PCP2&quot; &quot;TMEM176A&quot; &quot;DDX3Y&quot; &quot;MYRF&quot; &quot;LAMB3&quot; &quot;PLA2G4A&quot; &quot;HTR1A&quot; For this tutorial we will limit ourselves to the first set of pathways and use groupList to tell netDx to group transcriptomic data using pathways. NOTE: The pathway definition file should use the same identifier type as your patient data. For instance, if the genes in your transcriptomic data are represented using HGNC symbols, then your pathway definition file must also use HGNC symbols (e.g.ID2S), and not a different type of identifier, such as Ensembl IDs (which look like this: ENSG00000010404). groupList[[&quot;BRCA_mRNAArray-20160128&quot;]] &lt;- pathList Clinical: Single variables Models often include clinical variables such as demographic or disease-related features such as age, sex, or treatment regimen. In this example, we take two variables from the sample metadata, and include create one PSN for each variable. So here, we map the following: patient.age_at_initial_pathologic_diagnosis to age (just shorter) stage to STAGE These variables must be present in the colData() slot: pheno &lt;- colData(brca) head(pheno[,c(&quot;patient.age_at_initial_pathologic_diagnosis&quot;,&quot;STAGE&quot;)]) ## DataFrame with 6 rows and 2 columns ## patient.age_at_initial_pathologic_diagnosis STAGE ## &lt;integer&gt; &lt;integer&gt; ## TCGA-A1-A0SD 59 2 ## TCGA-A1-A0SE 56 1 ## TCGA-A1-A0SH 39 2 ## TCGA-A1-A0SJ 39 3 ## TCGA-A1-A0SK 54 2 ## TCGA-A1-A0SO 67 2 We now add the entry into groupList. The entry for clinical is special because netDx will look for corresponding variables in the sample metadata table, colData(), rather than looking for clinical within assays(brca). groupList[[&quot;clinical&quot;]] &lt;- list( age=&quot;patient.age_at_initial_pathologic_diagnosis&quot;, stage=&quot;STAGE&quot; ) We now tell netDx what similarity metric to use This is makeNets() just as we had seen in the previous exercise, which provides netDx with a custom function to generate similarity networks (i.e.features). We previously used the following code to create PSN based on Pearson correlation: (Do not paste this in) makePSN_NamedMatrix(..., writeProfiles=TRUE,...)` We will now make a different call to makePSN_NamedMatrix() but this time, requesting the use of the normalized difference similarity metric. This is achieved by calling the following code (Do not paste this in, either): makePSN_NamedMatrix(,..., simMetric=&quot;custom&quot;, customFunc=normDiff, writeProfiles=FALSE) normDiff is a function provided in the netDx package, but the user may define custom similarity functions in this block of code and pass those to makePSN_NamedMatrix(), using the customFunc parameters; additionally set simMetric to custom. Other presets provided by netDx include: sim.pearscale: Pearson correlation followed by exponential scaling; used with a vector sim.eucscale: Euclidean disance followed by exponential scaling; used with a vector normDiff: Normalized difference; used with a single variable such as age avgNormDiff: Average normalized difference; used with a vector When were done, this is what the makeNets function look like. Note: I realize this may be complicated. Future versions of netDx will simplify this syntax. makeNets &lt;- function(dataList, groupList, netDir,...) { netList &lt;- c() # make RNA nets (Pearson correlation) rna &lt;- &quot;BRCA_mRNAArray-20160128&quot; if (!is.null(groupList[[rna]])) { ## REMEMBER TO CHECK FOR NULL netList &lt;- makePSN_NamedMatrix( dataList[[rna]], rownames(dataList[[rna]]), groupList[[rna]], netDir, verbose=FALSE, writeProfiles=TRUE, ## define Pearson similarity as before ...) } # make clinical nets (normalized difference) netList2 &lt;- c() if (!is.null(groupList[[&quot;clinical&quot;]])) { netList2 &lt;- makePSN_NamedMatrix( dataList$clinical, rownames(dataList$clinical), groupList[[&quot;clinical&quot;]],netDir, simMetric=&quot;custom&quot;,customFunc=normDiff, ### Notice simMetric &amp; customFunc writeProfiles=FALSE, sparsify=TRUE, verbose=FALSE, ...) } netList &lt;- c(unlist(netList),unlist(netList2)) return(netList) } Build predictor Finally! We have: prepared our data, grouped RNA by pathways (fetchPathwayDefinitions(), readPathways()), created two PSN using clinical variables (groupList$clinical), and defined our similarity metrics (makeNets()). Now we build our predictors. For this tutorial, we use two train/test splits. For each split, we assign features a score between zero and two, and call features with score of 1+ feature-selected. Realistic parameters: When running this with your project, reasonable values are numSplits=10L (10 is a good start, just to see if you get signal, 100+ if firming up for publication), featScoreMax=10L, featSelCutoff=9L. t0 &lt;- Sys.time() set.seed(42) # make results reproducible outDir &lt;- paste(sprintf(&quot;%s2&quot;,tempdir()),&quot;pred_output&quot;,sep=getFileSep()) # use absolute path if (file.exists(outDir)) unlink(outDir,recursive=TRUE) numSplits &lt;- 2L model &lt;- suppressMessages( buildPredictor( dataList=brca, groupList=groupList, makeNetFunc=makeNets, outDir=outDir, numSplits=numSplits, featScoreMax=2L, featSelCutoff=1L, numCores=4L ) ) ## function(dataList, groupList, netDir,...) { ## netList &lt;- c() ## ## # make RNA nets (Pearson correlation) ## rna &lt;- &quot;BRCA_mRNAArray-20160128&quot; ## if (!is.null(groupList[[rna]])) { ## REMEMBER TO CHECK FOR NULL ## netList &lt;- makePSN_NamedMatrix( ## dataList[[rna]], ## rownames(dataList[[rna]]), ## groupList[[rna]], ## netDir, ## verbose=FALSE, ## writeProfiles=TRUE, ## define Pearson similarity as before ## ...) ## } ## ## # make clinical nets (normalized difference) ## netList2 &lt;- c() ## if (!is.null(groupList[[&quot;clinical&quot;]])) { ## netList2 &lt;- makePSN_NamedMatrix( ## dataList$clinical, ## rownames(dataList$clinical), ## groupList[[&quot;clinical&quot;]],netDir, ## simMetric=&quot;custom&quot;,customFunc=normDiff, ### Notice simMetric &amp; customFunc ## writeProfiles=FALSE, ## sparsify=TRUE, ## verbose=FALSE, ## ...) ## } ## netList &lt;- c(unlist(netList),unlist(netList2)) ## return(netList) ## } ## IS_TRAIN ## STATUS TRAIN TEST ## Luminal.A 184 46 ## other 75 19 ## ## Luminal.A nonpred &lt;NA&gt; ## 184 75 0 ## ## nonpred other &lt;NA&gt; ## 184 75 0 ## IS_TRAIN ## STATUS TRAIN TEST ## Luminal.A 184 46 ## other 75 19 ## ## Luminal.A nonpred &lt;NA&gt; ## 184 75 0 ## ## nonpred other &lt;NA&gt; ## 184 75 0 t1 &lt;- Sys.time() print(t1-t0) # time taken ## Time difference of 15.50749 mins The above settings were chosen to Lets actually load data generated by reasonable parameters, e.g.numSplits=10L, featScoreMax=10L, featSelCutoff=9L, generated for this tutorial: outFile &lt;- sprintf(&quot;%s2/CBW_Lab2_full.rda&quot;,tempdir()) download.file(&quot;https://github.com/RealPaiLab/CBW_CAN_DataIntegration_2021/raw/master/supporting_files/Lab2_files/brca_binary_pathways.rda&quot;, destfile=outFile) lnames &lt;- load(outFile) We can see the objects in the file using lnames(). Examine output As before, we get model results, using getResults() from our helper script, helper.R. source(&quot;helper.R&quot;) results &lt;- getResults(brca,model_full, featureSelCutoff=9L, featureSelPct=0.9) ## Detected 10 splits and 2 classes ## * Plotting performance ## * Compiling feature scores and calling selected features Lets examine our confusion matrix: confMat &lt;- confusionMatrix(model_full) This function returns the confusion matrix for each split, as well as the average shown in the image above: summary(confMat) ## Length Class Mode ## splitWiseConfMatrix 10 -none- list ## average 4 table numeric Visualize top pathways in Cytoscape We will now visualize top-scoring pathways using the Cytoscape visualization EnrichmentMap. Recall from the XXX module that an EnrichmentMap is a network visualization of related gene-sets, where each node is a pathway and edges connect similar pathways. Let us say we only want to see pathways that scored in some target range for most of the trials; i.e.consistently high-scoring pathways. We quantify this by asking only for features that score [EMapMinScore,EMapMaxScore] for EMapPctPass fraction of trials. Here we ask for features scoring 7+ out of 10 for at least 70% of the train/test splits. emap &lt;- makeInputForEnrichmentMap ( model=model_full, results=results, pathwayList=pathList, EMapMinScore=7L, EMapMaxSore=10L, EMapPctPass=0.7, outDir=&quot;/home/spai/data&quot; ### SP: CHANGE TO WORKSPACE ON AWS ) ## * Creating input files for EnrichmentMap ## * Writing files for network visualization This call will return paths to the output files, which you need to now download from AWS to your personal computer: emap ## $GMTfiles ## $GMTfiles$Luminal.A ## [1] &quot;/home/spai/data/Luminal.A.gmt&quot; ## ## $GMTfiles$other ## [1] &quot;/home/spai/data/other.gmt&quot; ## ## ## $NodeStyles ## $NodeStyles$Luminal.A ## [1] &quot;/home/spai/data/Luminal.A_nodeAttrs.txt&quot; ## ## $NodeStyles$other ## [1] &quot;/home/spai/data/other_nodeAttrs.txt&quot; netDx can directly generate EnrichmentMaps on a locally-installed version of Cytosape using RCy3 (LINK). This step needs a local copy of Cytoscape installed, so it wont work on the AWS instance. ###plotEmap(gmtFiles[[1]],nodeAttrFiles[[1]], ### groupClusters=TRUE, hideNodeLabels=TRUE) If you wanted to look at one anyway, you can download the input files shown in emap by opening your web browser to: http://your student instance&gt;. Then build an Enrichment map using Cytoscape on your laptop as discussed earlier in the Cancer Analysis workshop. When youre done, the Enrichment Map would look like this (below). The speech bubbles show pathway names within a couple top clusters. knitr::include_graphics(&quot;images/Lab2_EMap.jpg&quot;) You should be able to download the Cytoscape session file here to see the finished result. In practice, it can take a good portion of an hour to adjust the layout of the EnrichmentMap and often longer to explore the contents. But at a glance you can see that the top pathway sessionInfo sessionInfo() ## R version 4.0.5 (2021-03-31) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.2 LTS ## ## Matrix products: default ## BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so ## ## locale: ## [1] LC_CTYPE=C LC_NUMERIC=C LC_TIME=C LC_COLLATE=C LC_MONETARY=C ## [6] LC_MESSAGES=C LC_PAPER=en_US.UTF-8 LC_NAME=C LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] parallel stats4 stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] plotrix_3.8-1 ggplot2_3.3.3 Rtsne_0.15 netDx_1.2.3 ## [5] bigmemory_4.5.36 rhdf5_2.34.0 curatedTCGAData_1.12.1 MultiAssayExperiment_1.16.0 ## [9] SummarizedExperiment_1.20.0 Biobase_2.50.0 GenomicRanges_1.42.0 GenomeInfoDb_1.26.7 ## [13] IRanges_2.24.1 S4Vectors_0.28.1 BiocGenerics_0.36.1 MatrixGenerics_1.2.1 ## [17] matrixStats_0.58.0 ## ## loaded via a namespace (and not attached): ## [1] utf8_1.2.1 R.utils_2.10.1 tidyselect_1.1.1 RSQLite_2.2.7 ## [5] AnnotationDbi_1.52.0 grid_4.0.5 combinat_0.0-8 BiocParallel_1.24.1 ## [9] RNeXML_2.4.5 munsell_0.5.0 codetools_0.2-18 withr_2.4.2 ## [13] colorspace_2.0-1 highr_0.9 knitr_1.33 uuid_0.1-4 ## [17] zinbwave_1.12.0 rstudioapi_0.13 SingleCellExperiment_1.12.0 ROCR_1.0-11 ## [21] NMF_0.23.0 labeling_0.4.2 GenomeInfoDbData_1.2.4 farver_2.1.0 ## [25] bit64_4.0.5 vctrs_0.3.8 generics_0.1.0 xfun_0.23 ## [29] BiocFileCache_1.14.0 R6_2.5.0 doParallel_1.0.16 ggbeeswarm_0.6.0 ## [33] netSmooth_1.10.0 rsvd_1.0.5 RJSONIO_1.3-1.4 locfit_1.5-9.4 ## [37] bitops_1.0-7 rhdf5filters_1.2.1 cachem_1.0.5 DelayedArray_0.16.3 ## [41] assertthat_0.2.1 promises_1.2.0.1 scales_1.1.1 beeswarm_0.3.1 ## [45] gtable_0.3.0 phylobase_0.8.10 beachmat_2.6.4 rlang_0.4.11 ## [49] genefilter_1.72.1 splines_4.0.5 lazyeval_0.2.2 BiocManager_1.30.15 ## [53] yaml_2.2.1 reshape2_1.4.4 httpuv_1.6.1 tools_4.0.5 ## [57] bookdown_0.22 gridBase_0.4-7 ellipsis_0.3.2 jquerylib_0.1.4 ## [61] RColorBrewer_1.1-2 Rcpp_1.0.6 plyr_1.8.6 sparseMatrixStats_1.2.1 ## [65] progress_1.2.2 zlibbioc_1.36.0 purrr_0.3.4 RCurl_1.98-1.3 ## [69] prettyunits_1.1.1 viridis_0.6.1 cluster_2.1.1 tinytex_0.31 ## [73] magrittr_2.0.1 data.table_1.14.0 RSpectra_0.16-0 hms_1.1.0 ## [77] mime_0.10 evaluate_0.14 xtable_1.8-4 XML_3.99-0.6 ## [81] jpeg_0.1-8.1 gridExtra_2.3 shape_1.4.6 compiler_4.0.5 ## [85] scater_1.18.6 tibble_3.1.2 RCy3_2.10.2 crayon_1.4.1 ## [89] entropy_1.3.0 R.oo_1.24.0 htmltools_0.5.1.1 later_1.2.0 ## [93] tidyr_1.1.3 howmany_0.3-1 DBI_1.1.1 ExperimentHub_1.16.1 ## [97] dbplyr_2.1.1 MASS_7.3-53.1 rappdirs_0.3.3 Matrix_1.3-2 ## [101] ade4_1.7-16 R.methodsS3_1.8.1 igraph_1.2.6 pkgconfig_2.0.3 ## [105] bigmemory.sri_0.1.3 rncl_0.8.4 registry_0.5-1 locfdr_1.1-8 ## [109] scuttle_1.0.4 xml2_1.3.2 foreach_1.5.1 annotate_1.68.0 ## [113] vipor_0.4.5 bslib_0.2.5.1 rngtools_1.5 pkgmaker_0.32.2 ## [117] XVector_0.30.0 stringr_1.4.0 digest_0.6.27 pracma_2.3.3 ## [121] graph_1.68.0 softImpute_1.4-1 rmarkdown_2.8 edgeR_3.32.1 ## [125] DelayedMatrixStats_1.12.3 curl_4.3.1 kernlab_0.9-29 shiny_1.6.0 ## [129] lifecycle_1.0.0 nlme_3.1-152 jsonlite_1.7.2 clusterExperiment_2.10.1 ## [133] Rhdf5lib_1.12.1 BiocNeighbors_1.8.2 viridisLite_0.4.0 limma_3.46.0 ## [137] fansi_0.4.2 pillar_1.6.1 lattice_0.20-41 fastmap_1.1.0 ## [141] httr_1.4.2 survival_3.2-10 interactiveDisplayBase_1.28.0 glue_1.4.2 ## [145] png_0.1-7 iterators_1.0.13 BiocVersion_3.12.0 glmnet_4.1-1 ## [149] bit_4.0.4 stringi_1.6.2 sass_0.4.0 HDF5Array_1.18.1 ## [153] blob_1.2.1 BiocSingular_1.6.0 AnnotationHub_2.22.1 memoise_2.0.0 ## [157] dplyr_1.0.6 irlba_2.3.3 ape_5.5 "]]

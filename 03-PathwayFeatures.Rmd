# Lab 2: Pathway-level features

In this example, we will use ...

ADD FIGURE showing design here.

We also use several strategies and definitions of similarity to create features: 

 * Clinical variables: Each *variable* is its own feature (e.g. age); similarity is defined as *normalized difference*. 
 * Gene expression: Features are defined at the level of ***pathways***; i.e. a feature groups genes corresponding to the pathway. Similarity is defined as pairwise *Pearson correlation*
 * Proteomic and methylation data: Features are defined at the level of the entire *data layer*; a single feature is created for all of proteomic data, and the same for methylation. Similarity is defined by pairwise *Pearson correlation*

## Setup
Load the `netDx` package.

```{r,eval=FALSE}
suppressWarnings(suppressMessages(require(netDx)))
```

For this example we pull data from the The Cancer Genome Atlas through the BioConductor `curatedTCGAData` package. The fetch command automatically brings in a `MultiAssayExperiment` object. 
```{r,eval=FALSE}
suppressMessages(library(curatedTCGAData))
```

We use the `curatedTCGAData()` command to look at available assays in the breast cancer dataset. 
```{r,eval=FALSE}
curatedTCGAData(diseaseCode="BRCA", assays="*",dry.run=TRUE)
```

In this call we fetch only the gene expression, proteomic and methylation data; setting `dry.run=FALSE` initiates the fetching of the data.

```{r,eval=FALSE}
brca <- suppressMessages(
   curatedTCGAData("BRCA",
               c("mRNAArray","RPPA*","Methylation_methyl27*"),
	dry.run=FALSE))
```

Let's prepare the data:
```{r,eval=FALSE}
source("prepare_data.R")
brca <- prepareDataForCBW(brca)
```

## Rules to create features (patient similarity networks)

Our plan is to group gene expression data by pathways and clinical data by single variables. We will treat methylation and proteomic data each as a single feature, so each of those groups will contain the entire input table for those corresponding data types. 

In the code below, we fetch pathway definitions for January 2018 from (http://download.baderlab.org/EM_Genesets) and group gene expression data by pathways. To keep the example short, we limit to only three pathways, but in practice you would use all pathways meeting a size criterion; e.g. those containing between 10 and 500 genes. 

```{r,eval=FALSE}
groupList <- list()
```

### Pathway-level features
Let's group genes into *pathway-level features*, i.e. instead of one PSN for transcriptomic data, we create one PSN for each *pathway*, using transcriptomic data. So if you had a pathway set with 2,000 pathways, this would generate 2,000 input PSN.

There are two ways of providing pathway data:

1. You can **download** a compilation of pathways from curated databases using the `fetchPathwayDefinitions()` function in netDx, like so:
```{r,eval=FALSE}
pathList <- readPathways()
```
2. You can also provide a custom pathway set to netDx by reading in a GMT file containing those pathways:
```{r,eval=FALSE}
# add code for gmt file reading here. 
```
- ADD SENTENCE SAYING WHAT GMT FILE IS
- 

# genes in mRNA data are grouped by pathways

groupList[["BRCA_mRNAArray-20160128"]] <- pathList[1:3]


# clinical data is not grouped; each variable is its own feature
groupList[["clinical"]] <- list(
      age="patient.age_at_initial_pathologic_diagnosis",
	   stage="STAGE"
)
# for methylation generate one feature containing all probes
# same for proteomics data
tmp <- list(rownames(experiments(brca)[[2]]));
names(tmp) <- names(brca)[2]
groupList[[names(brca)[2]]] <- tmp

tmp <- list(rownames(experiments(brca)[[3]]));
names(tmp) <- names(brca)[3]
groupList[[names(brca)[3]]] <- tmp
```

## Define patient similarity for each network

We provide `netDx` with a custom function to generate similarity networks (i.e. features). The first block tells netDx to generate correlation-based networks using everything but the clinical data. This is achieved by the call:
```{r,eval=FALSE}
makePSN_NamedMatrix(..., writeProfiles=TRUE,...)`
```

The second block makes a different call to `makePSN_NamedMatrix()` but this time, requesting the use of the normalized difference similarity metric. This is achieved by calling:
```{r,eval=FALSE}
   makePSN_NamedMatrix(,..., 
                       simMetric="custom", customFunc=normDiff,
                       writeProfiles=FALSE)
```

`normDiff` is a function provided in the `netDx` package, but the user may define custom similarity functions in this block of code and pass those to `makePSN_NamedMatrix()`, using the `customFunc` parameter.

```{r,eval=FALSE}
makeNets <- function(dataList, groupList, netDir,...) {
	netList <- c() # initialize before is.null() check
	# correlation-based similarity for mRNA, RPPA and methylation data
	# (Pearson correlation)
	for (nm in setdiff(names(groupList),"clinical")) {
	   # NOTE: the check for is.null() is important!
		if (!is.null(groupList[[nm]])) {
		netList <- makePSN_NamedMatrix(dataList[[nm]],
		             rownames(dataList[[nm]]),
                   groupList[[nm]],netDir,verbose=FALSE,
		             writeProfiles=TRUE,...) 
		}
	}
	
	# make clinical nets (normalized difference)
	netList2 <- c()
	if (!is.null(groupList[["clinical"]])) {
	netList2 <- makePSN_NamedMatrix(dataList$clinical, 
		rownames(dataList$clinical),
		groupList[["clinical"]],netDir,
		simMetric="custom",customFunc=normDiff, # custom function
		writeProfiles=FALSE,
		sparsify=TRUE,verbose=TRUE,...)
	}
	netList <- c(unlist(netList),unlist(netList2))
	return(netList)
}

```

# Build predictor

Finally we make the call to build the predictor. 
 
```{r,eval=FALSE}
set.seed(42) # make results reproducible

# location for intermediate work
# set keepAllData to TRUE to not delete at the end of the 
# predictor run.
# This can be useful for debugging.
outDir <- paste(tempdir(),"pred_output",sep=getFileSep()) # use absolute path
numSplits <- 2L
out <- suppressMessages(
   buildPredictor(dataList=brca,groupList=groupList,
      makeNetFunc=makeNets,
      outDir=outDir, ## netDx requires absolute path
      numSplits=numSplits, featScoreMax=2L, featSelCutoff=1L,
	   numCores=1L)
)
```

# Examine output
The results are stored in the list object returned by the `buildPredictor()` call.
This list contains:

* `inputNets`: all input networks that the model started with. 
* `Split<i>`: a list with results for each train-test split
  * `featureScores`: feature scores for each label (list with `g` entries, where `g` is number of patient labels). Each entry contains the feature selection scores for the corresponding label.
  * `featureSelected`: vector of features that pass feature selection. List of length `g`, with one entry per label.
  * `predictions`: real and predicted labels for test patients
  * `accuracy`: percent accuracy of predictions

```{r,eval=FALSE}
summary(out)
summary(out$Split1)
```

Compute accuracy for three-way classificationL

```{r,eval=FALSE}
# Average accuracy
st <- unique(colData(brca)$STATUS) 
acc <- matrix(NA,ncol=length(st),nrow=numSplits) 
colnames(acc) <- st 
for (k in 1:numSplits) { 
	pred <- out[[sprintf("Split%i",k)]][["predictions"]];
	tmp <- pred[,c("ID","STATUS","TT_STATUS","PRED_CLASS",
	                 sprintf("%s_SCORE",st))]
	for (m in 1:length(st)) {
	   tmp2 <- subset(tmp, STATUS==st[m])
	   acc[k,m] <- sum(tmp2$PRED==tmp2$STATUS)/nrow(tmp2)
	}
}
print(round(acc*100,2))
```
Also, examine the confusion matrix. We can see that the model perfectly classifies basal tumours, but performs poorly in distinguishing between the two types of luminal tumours. 

```{r, eval=FALSE}
res <- out$Split1$predictions
print(table(res[,c("STATUS","PRED_CLASS")]))
```

# sessionInfo
```{r,eval=FALSE}
sessionInfo()
```

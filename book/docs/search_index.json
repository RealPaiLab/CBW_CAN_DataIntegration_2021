[["index.html", "Multi-modal Data Integration CBW Cancer Analysis Workshop", " Multi-modal Data Integration CBW Cancer Analysis Workshop Instructor: Shraddha Pai last modified 2021-06-04 "],["introduction.html", "Introduction Course materials Data Labs Instructions", " Introduction This book contains lab exercises for Module 11: Multi-modal Data Integration, as part of the Canadian Bioinformatics Workshop Cancer Analysis (CAN) Workshop. Course materials You can download course slides here LINK TBA We will have two lab exercises, where we build patient classifiers using multi-modal data integration, using netDx.1,2 Data For both lab exercises, we will use multi-modal breast cancer data from The Cancer Genome Atlas,3 and classify tumours by molecular subtypes originally defined using gene expression profiles. In particular, we will focus on classifying tumours as being of either Luminal A, Luminal B, or Basal-like subtypes. These subtypes vary by prevalence, prognosis for survival and relapse, activated cellular signaling pathways, immunohistochemical markers and treatment options.4 Luminal A tumours are the most common subtype (50-60% of all breast tumours), with low histological grade; good prognosis; ER+; HER2-. Luminal B tumours are less common (15-20%), with worse prognosis than Luminal A; ER+; HER2 status variable. Basal-like tumours are also less common (8-37%), with distinctive histological features (infiltrative ductal tumours), poor prognosis, ER-; HER2- This dataset was selected because it has characteristics of a common use cancer in cancer genomics: * There are pre-defined subtypes discovered using class discovery approaches (unsupervised methods such as clustering) OR defined by the clinical problem * Subtypes are correlated with differences in clinical outcome and choice of treatment * For the purposes of this lab, it is instructive to use subtypes with known cellular signaling pathways Labs LAB 1: A gentle introduction We will classify breast tumours as being one of three subtypes: Luminal A, Luminal B, and Basal-like. For this we will build a three-way classifier by integrating four types of -omic data: gene expression, miRNA, DNA methylation and proteomics. The design will be simple, using a single patient similarity network (feature) created from each layer. Similarity will be defined as pairwise Pearson correlation of profiles. Each network will use all measures from a given -omic data type (no filtering or grouping). LAB 2: Pathway features &amp; custom similarity metrics We will build a binary classifier of breast tumour subtype using gene expression and clinical data, but will use a slightly more complex design. We will define features at the pathway level for gene expression, so we can score pathways by their ability to predict outcome. With clinical data, we will define features at the level of individual clinical variables (e.g.age). We will also introduce the idea of using custom similarity metrics. Instructions Labs will use Rstudio. Each lab will be provided as blocks of R code you will copy-paste into Rstudio to follow the building of the predictor. Code blocks to be pasted will be in yellow like so. x &lt;- 5 If you hover your mouse over the block, you should see a little clipboard icon. Clicking on that icon will allow you to copy the block in one shot. I would use that. In each case, the result of executing a code block is shown directly after the code, in grey blocks like the one below. These are not intended to be pasted in. 5 Sometimes we show pseudocode or conceptual code blocks; these will also be in grey. None of these are intended to be pasted in. # do not paste me in! loop_over (all my patients){ do something useful; } Thats about it! Lets go! References 1. Pai, S. et al. netDx: Interpretable patient classification using integrated patient similarity networks. Mol. Syst. Biol. 15, e8497 (2019). 2. Pai, S. et al. netDx: Software for building interpretable patient classifiers by multi-omic data integration using patient similarity networks. F1000Research 9, 1239 (2021). 3. Comprehensive molecular portraits of human breast tumours. Nature 490, 6170 (2012). 4. Yersal, O. &amp; Barutca, S. Biological subtypes of breast cancer: Prognostic and therapeutic implications. World J. Clin. Oncol. 5, 412424 (2014). "],["module-11-lab-1-three-way-classifier-from-four-genomic-layers.html", "Module 11 Lab 1: Three-way classifier from four genomic layers Introduction Get and prepare data Create feature design rules Build predictor Examine results Conclusion sessionInfo", " Module 11 Lab 1: Three-way classifier from four genomic layers This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License. This means that you are able to copy, share and modify the work, as long as the result is distributed under the same license. Introduction In this lab we will build a predictor to classify three different types of breast tumours, two of a luminal subtype (Luminal A and Luminal B), and one of a basal subtype. For this we will use data from the The Cancer Genome Atlas, and will integrate four types of -omic data: gene expression (measured on XXX arrays) DNA methylation (XXX arrays) proteomic measures from XXX, and miRNA sequencing Figure 1: Lab 1 design: We will integrate four layers of genomic data. Each layer will be converted into a single patient similarity network using Pearson correlation for pairwise similarity. Get and prepare data In this example, we use curated multi-modal data from The Cancer Genome Atlas, gotten from the BioConductor curatedTCGAData package. Data for all cancer types profiled in TCGA are available through this package; see this tutorial for details. suppressMessages(library(curatedTCGAData)) Lets take a look at the available data for breast cancer, without downloading any (set dry.run=TRUE). Note that the new release of BioConductor (3.13) actually allows users to fetch one of two versions of TCGA data. curatedTCGAData(diseaseCode=&quot;BRCA&quot;, assays=&quot;*&quot;,dry.run=TRUE) Now lets actually download the data, getting just the four layers we need: brca &lt;- suppressMessages(curatedTCGAData(&quot;BRCA&quot;, c(&quot;mRNAArray&quot;,&quot;Methylation_methyl27&quot;, &quot;RPPAArray&quot;,&quot;miRNASeqGene&quot;), dry.run=FALSE)) This call returns a MultiAssayExperiment object. Recall that this is a container for storing multiple assays performed on the same set of samples. See this tutorial to learn more. Lets briefly explore the brca MultiAssayExperiment object. brca assays() returns a list with all -omic data associated with this object. summary(assays(brca)) names() shows the datatypes in each slot of assays(): names(assays(brca)) So miRNA data is in slot 1, gene expression in slot 2, etc., We can subset the data to see what it looks like. Lets do that for the miRNA data, looking at just the first five measures mir &lt;- assays(brca)[[&quot;BRCA_miRNASeqGene-20160128&quot;]] head(mir[,1:5]) Patient metadata is contained in the colData() slot. Rows contain data for each patient and columns contain measures such as clinical characteristics: pheno &lt;- colData(brca) colnames(pheno)[1:20] head(pheno[,1:5]) This next code block prepares the TCGA data. This includes: removing duplicate samples reformatting patient IDs (e.g.removing spaces and hyphens) creating an ID column in colData(brca), which contains unique patient IDs creating a STATUS column in colData(brca) which contains the patient labels (i.e what we want netDx to classify). In practice you would prepare the dataset once and save it to file, then separately load it before running netDx; i.e.decouple data processing and running the predictor. The data processing code has been moved into a supporting file, prepare_data.R. You can explore it after the lab to see how some things are achieved (e.g.removing duplicate samples). For now, lets just run it. source(&quot;prepare_data.R&quot;) brca &lt;- prepareDataForCBW(brca) Notice that we now have ID and STATUS columns in the sample metadata table. netDx requires ID and STATUS columns in colData(). Be sure to define these in the code you use to prepare the data. Otherwise the function to build the predictor will return an error. pheno &lt;- colData(brca) head(pheno[,c(&quot;ID&quot;,&quot;STATUS&quot;)]) table(pheno$STATUS,useNA=&quot;always&quot;) # good practice: useNA=&quot;always&quot; shows missing values Create feature design rules Now lets set up the data for input to netDx. netDx allows the user to define how data is converted into patient similarity networks (or PSNs), which are the features that go into the model. This is done specifically by telling the model how to: group different types of data and define similarity for each of these (e.g.Pearson correlation, normalized difference, etc.,). The relevant input parameters are: groupList: sets of input data that would correspond to individual networks (e.g.genes grouped into pathways) makeNets(): an R function telling netDx what similarity metric to use for each data layer Lets start by loading the netDx package. suppressWarnings(suppressMessages(require(netDx))) Lets set up each of the input arguments one by one. groupList What is this: groupList tells netDx how to group measures within a layer, to generate a PSN. Measures could be individual genes, proteins, CpG bases (in DNA methylation data), clinical variables, etc., In this simple example we just create a single PSN for each datatype, containing all measures from that datatype. expr &lt;- assays(brca) groupList &lt;- list() for (k in 1:length(expr)) { # loop over all layers cur &lt;- expr[[k]]; nm &lt;- names(expr)[k] # all measures from this layer go into our single PSN groupList[[nm]] &lt;- list(nm=rownames(cur)) # assign same layer name as in input data names(groupList[[nm]])[1] &lt;- nm; } Notice that groupList is a two tiered list, or list-of-lists. The first tier is for each data layers, with names matching those in assays(brca). The second tier contains all the PSNs we want to make for that layer. In this lab exercise we create only one PSN per data layer, using all the measures from an -omic assay. e.g.One PSN based on similarity across entire transcriptome, one for methylome, etc.,). So in this lab exercise, the inner tier simply contains one entry, with all measures for the given layer. This design will get more interesting in Lab 2, when we create pathway-level features. Lets take a look at groupList. Here is the first tier: summary(groupList) And the second tier: names(groupList[[&quot;BRCA_mRNAArray-20160128&quot;]]) length(groupList[[&quot;BRCA_mRNAArray-20160128&quot;]][[1]]) head(groupList[[&quot;BRCA_mRNAArray-20160128&quot;]][[1]]) Define patient similarity for each network The makeNets function tells the predictor how to create networks from provided input data. This function requires dataList,groupList, and netDir as input variables. The residual ... parameter is to pass additional variables to makePSN_NamedMatrix(), notably numCores (number of parallel jobs). netDx requires that this function have: dataList,groupList, and netDir as input variables. The residual ... parameter is to pass additional variables to makePSN_NamedMatrix(), notably number of cores for parallel processing (numCores). makeNets &lt;- function(dataList, groupList, netDir,...) { netList &lt;- c() # initialize before is.null() check layerNames &lt;- c(&quot;BRCA_miRNASeqGene-20160128&quot;, &quot;BRCA_mRNAArray-20160128&quot;, &quot;BRCA_RPPAArray-20160128&quot;, &quot;BRCA_Methylation_methyl27-20160128&quot;) for (nm in layerNames){ ## for each layer if (!is.null(groupList[[nm]])){ ## must check for null for each layer netList_cur &lt;- makePSN_NamedMatrix( dataList[[nm]], rownames(dataList[[nm]]), ## names of measures (e.g. genes, CpGs) groupList[[nm]], ## how to group measures in that layer netDir, ## leave this as-is, netDx will figure out where this is. verbose=FALSE, writeProfiles=TRUE, ## use Pearson correlation-based similarity ... ) netList &lt;- c(netList,netList_cur) ## just leave this in } } return(unlist(netList)) ## just leave this in } While netDx provides a high degree of flexibility in achieving your design of choice, it is up to the user to ensure that the design, i.e.choice of similarity metrics and variable groupings, is appropriate for your application. Domain knowledge is almost likely required for good design. Build predictor Finally we call the function that runs the netDx predictor. We provide: patient data (dataList) grouping rules (groupList) function to create PSN from data, includes choice of similarity metric (makeNetFunc) number of train/test splits over which to collect feature scores and average performance: numSplits, maximum score for features in one round of feature selection (featScoreMax, set to 10) threshold to call feature-selected networks for each train/test split (featSelCutoff); only features scoring this value or higher will be used to classify test patients, number of cores to use for parallel processing (numCores). The call below runs 2 train/test splits, to be able to run fast. Within each split, it: splits data into train/test using the default split of 80:20 (trainProp=0.8) score networks between 0 to 2 (i.e.featScoreMax=2L) uses networks that score &gt;=1 out of 2 (featSelCutoff=1L) to classify test samples for that split. These are unrealistically low values set so the example will run fast. In practice a good starting point is featScoreMax=10, featSelCutoff=9 and numSplits=10L, but these parameters depend on the sample sizes in the dataset and heterogeneity of the samples. set.seed(42) # make results reproducible outDir &lt;- paste(tempdir(),randAlphanumString(), &quot;pred_output&quot;,sep=getFileSep()) if (file.exists(outDir)) unlink(outDir,recursive=TRUE) t0 &lt;- Sys.time() model &lt;- suppressMessages(buildPredictor( dataList=brca, ## your data groupList=groupList, ## grouping strategy makeNetFunc=makeNets, ## function to build PSNs outDir=outDir, ## output directory trainProp=0.8, ## pct of samples to use to train model in ## each split numSplits=2L, ## number of train/test splits featSelCutoff=1L, ## threshold for calling something ## feature-selected featScoreMax=2L, ## max score for feature selection numCores=8L, ## set higher for parallelizing debugMode=FALSE, keepAllData=FALSE, ## set to TRUE for debugging or low-level files used by the predictor logging=&quot;none&quot; )) t1 &lt;- Sys.time() print(t1-t0) Examine results The results are stored in the list object returned by the buildPredictor() call. This list contains: inputNets: all input networks that the model started with. Split&lt;i&gt;: results for each train-test split (list) predictions: real and predicted labels for test patients accuracy: percent accuracy of predictions featureScores: feature scores for each label (list with g entries, where g is number of patient labels). Each entry contains the feature selection scores for the corresponding label. featureSelected: features passing feature selection in a split (list of length g, with one entry per label) summary(model) summary(model$Split1) Get model results Now we get model output, including performance for various train/test splits and consistently high-scoring features. Weve actually generated results using more real-world parameters, including 10 train/test splits and a greater dynamic range for feature scores (featScoreMax=10L and featSelCutoff=9L). Lets load those for a better experience exploring results: outFile &lt;- sprintf(&quot;%s/CBW_Lab1_full.rda&quot;,tempdir()) download.file(&quot;https://github.com/RealPaiLab/CBW_CAN_DataIntegration_2021/raw/master/supporting_files/Lab1_files/Lab1_10splits.rda&quot;, destfile=outFile) lnames &lt;- load(outFile) helper.R contains convenience functions to do this, which will be integrated into upcoming versions of netDx. In the function below, we define top-scoring features as those which score at least 2 in at least half of the train/test splits source(&quot;helper.R&quot;) results &lt;- getResults(brca,model_full,featureSelCutoff=9L, featureSelPct=0.9) results contains performance, selectedFeatures for each patient label, and the table of feature scores. summary(results) Look at the performance: results$performance Look at feature scores for all labels, across all train-test splits: results$featureScores And here are selected features, which are those scoring 2 out of 2 in at least half of the splits. This threshold is simply for illustration. In practice we would run at least 10 train/test splits (ideally 100+), and look for features that score 7+ out of 10 in &gt;70% splits. results$selectedFeatures We finally get the integrated PSN and visualize it using a tSNE plot: psnFile &lt;- sprintf(&quot;%s/psn.rda&quot;,tempdir()) download.file(&quot;https://github.com/RealPaiLab/CBW_CAN_DataIntegration_2021/raw/master/supporting_files/Lab1_files/Lab1_PSN.rda&quot;, destfile=outFile) load(outFile) #psn &lt;- getPSN(brca,groupList_full,makeNets_full,results$selectedFeatures) tsne &lt;- tSNEPlotter( psn$patientSimNetwork_unpruned, colData(brca) ) Conclusion Congratulations! You have successfully classified three types of tumours by integrating four different -omic layers (transcriptomic, methylomic,proteomic and miRNA). We end this tutorial with a call to sessionInfo() which prints the complete environment information for your R session. This is standard output that should be reported to R package managers when you write in with a question, particularly if reporting an error or bug. Sometimes a particular underlying dependency package may be the cause of an error, or you may need to upgrade to a newer version of the package. By including this info in an email, you will allow the other person to better solve your issue. sessionInfo sessionInfo() ## R version 4.0.5 (2021-03-31) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.2 LTS ## ## Matrix products: default ## BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so ## ## locale: ## [1] LC_CTYPE=C LC_NUMERIC=C LC_TIME=C LC_COLLATE=C ## [5] LC_MONETARY=C LC_MESSAGES=C LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] parallel stats4 stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] plotrix_3.8-1 ggplot2_3.3.3 Rtsne_0.15 netDx_1.2.3 ## [5] bigmemory_4.5.36 rhdf5_2.34.0 curatedTCGAData_1.12.1 MultiAssayExperiment_1.16.0 ## [9] SummarizedExperiment_1.20.0 Biobase_2.50.0 GenomicRanges_1.42.0 GenomeInfoDb_1.26.7 ## [13] IRanges_2.24.1 S4Vectors_0.28.1 BiocGenerics_0.36.1 MatrixGenerics_1.2.1 ## [17] matrixStats_0.58.0 ## ## loaded via a namespace (and not attached): ## [1] utf8_1.2.1 R.utils_2.10.1 tidyselect_1.1.1 ## [4] RSQLite_2.2.7 AnnotationDbi_1.52.0 grid_4.0.5 ## [7] combinat_0.0-8 BiocParallel_1.24.1 RNeXML_2.4.5 ## [10] munsell_0.5.0 codetools_0.2-18 withr_2.4.2 ## [13] colorspace_2.0-1 highr_0.9 knitr_1.33 ## [16] uuid_0.1-4 zinbwave_1.12.0 rstudioapi_0.13 ## [19] SingleCellExperiment_1.12.0 ROCR_1.0-11 NMF_0.23.0 ## [22] labeling_0.4.2 GenomeInfoDbData_1.2.4 farver_2.1.0 ## [25] bit64_4.0.5 vctrs_0.3.8 generics_0.1.0 ## [28] xfun_0.23 BiocFileCache_1.14.0 R6_2.5.0 ## [31] doParallel_1.0.16 ggbeeswarm_0.6.0 netSmooth_1.10.0 ## [34] rsvd_1.0.5 RJSONIO_1.3-1.4 locfit_1.5-9.4 ## [37] bitops_1.0-7 rhdf5filters_1.2.1 cachem_1.0.5 ## [40] DelayedArray_0.16.3 assertthat_0.2.1 promises_1.2.0.1 ## [43] scales_1.1.1 beeswarm_0.3.1 gtable_0.3.0 ## [46] phylobase_0.8.10 beachmat_2.6.4 rlang_0.4.11 ## [49] genefilter_1.72.1 splines_4.0.5 lazyeval_0.2.2 ## [52] BiocManager_1.30.15 yaml_2.2.1 reshape2_1.4.4 ## [55] httpuv_1.6.1 tools_4.0.5 bookdown_0.22 ## [58] gridBase_0.4-7 ellipsis_0.3.2 jquerylib_0.1.4 ## [61] RColorBrewer_1.1-2 Rcpp_1.0.6 plyr_1.8.6 ## [64] sparseMatrixStats_1.2.1 progress_1.2.2 zlibbioc_1.36.0 ## [67] purrr_0.3.4 RCurl_1.98-1.3 prettyunits_1.1.1 ## [70] viridis_0.6.1 cluster_2.1.1 tinytex_0.31 ## [73] magrittr_2.0.1 data.table_1.14.0 RSpectra_0.16-0 ## [76] hms_1.1.0 mime_0.10 evaluate_0.14 ## [79] xtable_1.8-4 XML_3.99-0.6 jpeg_0.1-8.1 ## [82] gridExtra_2.3 shape_1.4.6 compiler_4.0.5 ## [85] scater_1.18.6 tibble_3.1.2 RCy3_2.10.2 ## [88] crayon_1.4.1 R.oo_1.24.0 htmltools_0.5.1.1 ## [91] entropy_1.3.0 later_1.2.0 tidyr_1.1.3 ## [94] howmany_0.3-1 DBI_1.1.1 ExperimentHub_1.16.1 ## [97] dbplyr_2.1.1 MASS_7.3-53.1 rappdirs_0.3.3 ## [100] Matrix_1.3-2 ade4_1.7-16 R.methodsS3_1.8.1 ## [103] igraph_1.2.6 pkgconfig_2.0.3 bigmemory.sri_0.1.3 ## [106] rncl_0.8.4 registry_0.5-1 locfdr_1.1-8 ## [109] scuttle_1.0.4 xml2_1.3.2 foreach_1.5.1 ## [112] annotate_1.68.0 vipor_0.4.5 bslib_0.2.5.1 ## [115] rngtools_1.5 pkgmaker_0.32.2 XVector_0.30.0 ## [118] stringr_1.4.0 digest_0.6.27 pracma_2.3.3 ## [121] graph_1.68.0 softImpute_1.4-1 rmarkdown_2.8 ## [124] edgeR_3.32.1 DelayedMatrixStats_1.12.3 curl_4.3.1 ## [127] kernlab_0.9-29 shiny_1.6.0 lifecycle_1.0.0 ## [130] nlme_3.1-152 jsonlite_1.7.2 clusterExperiment_2.10.1 ## [133] Rhdf5lib_1.12.1 BiocNeighbors_1.8.2 viridisLite_0.4.0 ## [136] limma_3.46.0 fansi_0.4.2 pillar_1.6.1 ## [139] lattice_0.20-41 fastmap_1.1.0 httr_1.4.2 ## [142] survival_3.2-10 interactiveDisplayBase_1.28.0 glue_1.4.2 ## [145] png_0.1-7 iterators_1.0.13 BiocVersion_3.12.0 ## [148] glmnet_4.1-1 bit_4.0.4 stringi_1.6.2 ## [151] sass_0.4.0 HDF5Array_1.18.1 blob_1.2.1 ## [154] BiocSingular_1.6.0 AnnotationHub_2.22.1 memoise_2.0.0 ## [157] dplyr_1.0.6 irlba_2.3.3 ape_5.5 "],["module-11-lab-2-pathway-level-features.html", "Module 11 Lab 2: Pathway-level features Introduction Get and prepare data Create feature design rules Build predictor Examine results Visualize top pathways in Cytoscape sessionInfo", " Module 11 Lab 2: Pathway-level features This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License. This means that you are able to copy, share and modify the work, as long as the result is distributed under the same license. Introduction In this example, we will learn how to: Use custom similarity metrics Group variables into biologically-meaningful units such as pathways, for improved interpretability Here, we will again use breast cancer samples, and discriminate between Luminal A, Luminal B and basal-like tumours. We will limit ourselves to clinical data and gene expression data but will make the following design changes: Clinical variables: A feature (or patient similarity network;PSN) will be defined at the level of selected variables (e.g.age); we will define similarity as normalized difference. Gene expression: Features will be defined at the level of pathways; i.e.each feature groups only those genes corresponding to the pathway. Similarity is defined as pairwise Pearson correlation. In practice I recommend running a predictor design with 2-3 different sets of pathway definitions, and comparing the predictive pathway themes. For instance, it could be useful to compare results from using all curated pathways, to just domain-specific ones. Feature design is something of an art, and the choice of pathways depends on what your goals with building the predictor are. Are you looking to prioritize a known set of biological processes or interested in general discovery? These are tradeoffs. At the very least I would recommend running with all curated pathways as a baseline, because you may generate novel hypotheses. Note that while in this design we group gene expression measures into pathways, the same design can be used to group other types of data based on prior knowledge. For instance, measures from imaging data could be grouped by prior knowledge of correlated networks of regions of interest subserving specific functions. Figure 2: Lab 2 design: We will integrate clinical and gene expression data. Each layer will be converted into a single patient similarity network using Pearson correlation for pairwise similarity. Get and prepare data Lets fetch the BRCA data using curatedTCGAData again, this time only the gene expression data. Remember, the clinical data we automatically get in the colData() slot returned. suppressMessages(library(curatedTCGAData)) brca &lt;- suppressMessages( curatedTCGAData( &quot;BRCA&quot;,c(&quot;mRNAArray&quot;), dry.run=FALSE) ) Lets look at the data. Notice that we now only have one -omic assay, gene expression measures from microarrays. brca As before, we prepare the data. I highly recommend separating the script that prepares the data from the one running the predictor for improved management, readability and debuggability. source(&quot;prepare_data.R&quot;) brca &lt;- prepareDataForCBW(brca, setBinary=TRUE) Create feature design rules Load the netDx package and initialize the groupList object, where we will store our grouping rules. Recall that groupList is a list-of-lists, with the top tier containing data layer names, and that the layer names must match names(assays(brca)) or whatever your MultiAssayExperiment object is called. suppressWarnings(suppressMessages(require(netDx))) groupList &lt;- list() RNA: Pathway features Lets group genes into pathway-level features, i.e.instead of one PSN for transcriptomic data, we create one PSN for each pathway. So if you had a pathway set with 2,000 curated pathways, this would generate 2,000 input PSN. This design changes model-building time to several hours, so avoid large gene sets (e.g.the full set of ~44,000 Gene Ontology terms, or even ~29,000 GO Biological Process terms). A reasonable start is a compilation of pathways from all curated pathway databases, as in below. Whichever list you use can be pruned by constraining the min/max number of genes in a set, but the size is something to keep in mind. There are two ways of providing pathway data to netDx: 1. You can download a compilation of pathways from curated databases using the fetchPathwayDefinitions() function in netDx, like so: x &lt;- fetchPathwayDefinitions(&quot;March&quot;,2021) x The above pathway set was downloaded from download.baderlab.org/EM_Genesets, which is a good resource for routinely-updated curated pathway definitions. Pathways are compiled from Reactome, Panther, NCI, MSigDB, etc.,,5 and data is contained in GMT format, a common format to represent gene-sets, such as pathways. You can see from the value of x that the file isnt downloaded to our working directory, but rather is stored in a BioConductor-specific location for files (file cache), using the BiocFileCache class. This way if we rerun the script, BioConductor will only download the file again if it has changed since our last download. Here is an example of the GMT format: Figure 3: Lab 2: Example of GMT file format. We then use readPathways() to read the pathways into a list format to provide the predictor with. So the full call looks like this: pathList &lt;- readPathways(fetchPathwayDefinitions(&quot;March&quot;,2021)) head(pathList) Alternatively, you can also provide a custom pathway set to netDx by reading in a GMT file, using the readPathways() function. In this example, Ive downloaded a geneset of pathways often dysregulated in cancer, set C6 from MSigDB:6 gmtFile &lt;- sprintf(&quot;%s2/cancer_pathways.gmt&quot;,tempdir()) if (!file.exists(sprintf(&quot;%s2&quot;,tempdir()))) { dir.create(sprintf(&quot;%s2&quot;,tempdir())) } download.file(&quot;https://raw.githubusercontent.com/RealPaiLab/CBW_CAN_DataIntegration_2021/master/supporting_files/c6.all.v7.4.symbols.gmt&quot;,gmtFile) x &lt;- readPathways(gmtFile) x[1:3] For this tutorial we will limit ourselves to the first set of pathways and use groupList to tell netDx to group transcriptomic data using pathways. The pathway definition file should use the same identifier type as your patient data. For instance, if the genes in your transcriptomic data are represented using HGNC symbols, then your pathway definition file must also use HGNC symbols (e.g.ID2S), and not a different type of identifier, such as Ensembl IDs (which look like this: ENSG00000010404). groupList[[&quot;BRCA_mRNAArray-20160128&quot;]] &lt;- pathList Clinical: Single variables Models often include clinical variables such as demographic or disease-related features such as age, sex, or treatment regimen. In this example, we take two variables from the sample metadata, and include create one PSN for each variable. So here, we map the following: patient.age_at_initial_pathologic_diagnosis to age (just shorter) stage to STAGE These variables must be present in the colData() slot: pheno &lt;- colData(brca) head(pheno[,c(&quot;patient.age_at_initial_pathologic_diagnosis&quot;,&quot;STAGE&quot;)]) We now add the entry into groupList. The entry for clinical is special because netDx will look for corresponding variables in the sample metadata table, colData(), rather than looking for clinical within assays(brca). groupList[[&quot;clinical&quot;]] &lt;- list( age=&quot;patient.age_at_initial_pathologic_diagnosis&quot;, stage=&quot;STAGE&quot; ) We now tell netDx what similarity metric to use This is makeNets() just as we had seen in the previous exercise, which provides netDx with a custom function to generate similarity networks (i.e.features). We previously used the following code to create PSN based on Pearson correlation: makePSN_NamedMatrix(..., writeProfiles=TRUE,...)` We will now make a different call to makePSN_NamedMatrix() but this time, requesting the use of the normalized difference similarity metric. This is achieved by calling the following code: makePSN_NamedMatrix(,..., simMetric=&quot;custom&quot;, customFunc=normDiff, writeProfiles=FALSE) normDiff is a function provided in the netDx package, but the user may define custom similarity functions in this block of code and pass those to makePSN_NamedMatrix(), using the customFunc parameters; additionally set simMetric to custom. Other presets provided by netDx include: sim.pearscale: Pearson correlation followed by exponential scaling; used with a vector sim.eucscale: Euclidean disance followed by exponential scaling; used with a vector normDiff: Normalized difference; used with a single variable such as age avgNormDiff: Average normalized difference; used with a vector When were done, this is what the makeNets function look like. Note: I realize this may be complicated. Future versions of netDx will simplify this syntax. makeNets &lt;- function(dataList, groupList, netDir,...) { netList &lt;- c() # make RNA nets (Pearson correlation) rna &lt;- &quot;BRCA_mRNAArray-20160128&quot; if (!is.null(groupList[[rna]])) { ## REMEMBER TO CHECK FOR NULL netList &lt;- makePSN_NamedMatrix( dataList[[rna]], rownames(dataList[[rna]]), groupList[[rna]], netDir, verbose=FALSE, writeProfiles=TRUE, ## define Pearson similarity as before ...) } # make clinical nets (normalized difference) netList2 &lt;- c() if (!is.null(groupList[[&quot;clinical&quot;]])) { netList2 &lt;- makePSN_NamedMatrix( dataList$clinical, rownames(dataList$clinical), groupList[[&quot;clinical&quot;]],netDir, simMetric=&quot;custom&quot;,customFunc=normDiff, ### Notice simMetric &amp; customFunc writeProfiles=FALSE, sparsify=TRUE, verbose=FALSE, ...) } netList &lt;- c(unlist(netList),unlist(netList2)) return(netList) } Build predictor Finally! We have: prepared our data, grouped RNA by pathways (fetchPathwayDefinitions(), readPathways()), created two PSN using clinical variables (groupList$clinical), and defined our similarity metrics (makeNets()). Now we build our predictors. For this tutorial, we use two train/test splits. For each split, we assign features a score between zero and two, and call features with score of 1+ feature-selected. Realistic parameters: When running this with your project, reasonable values are numSplits=10L (10 is a good start, just to see if you get signal, 100+ if firming up for publication), featScoreMax=10L, featSelCutoff=9L. t0 &lt;- Sys.time() set.seed(42) # make results reproducible outDir &lt;- paste(sprintf(&quot;%s2&quot;,tempdir()),&quot;pred_output&quot;,sep=getFileSep()) # use absolute path if (file.exists(outDir)) unlink(outDir,recursive=TRUE) numSplits &lt;- 2L model &lt;- suppressMessages( buildPredictor( dataList=brca, groupList=groupList, makeNetFunc=makeNets, outDir=outDir, numSplits=numSplits, featScoreMax=2L, featSelCutoff=1L, numCores=4L ) ) t1 &lt;- Sys.time() print(t1-t0) # time taken The above settings were chosen to Lets actually load data generated by reasonable parameters, e.g.numSplits=10L, featScoreMax=10L, featSelCutoff=9L, generated for this tutorial: outFile &lt;- sprintf(&quot;%s2/CBW_Lab2_full.rda&quot;,tempdir()) download.file(&quot;https://github.com/RealPaiLab/CBW_CAN_DataIntegration_2021/raw/master/supporting_files/Lab2_files/brca_binary_pathways.rda&quot;, destfile=outFile) lnames &lt;- load(outFile) We can see the objects in the file using lnames(). Examine results As before, we get model results, using getResults() from our helper script, helper.R. source(&quot;helper.R&quot;) results &lt;- getResults(brca,model_full, featureSelCutoff=9L, featureSelPct=0.9) As this is binary classification, we get ROC and precision-recall curves (bottom panel). The average AUROC and AUPR are shown in the top panel. Lets take a look at the average performance: perf &lt;- results$performance round(mean(perf$splitAUROC),2)*100 round(mean(perf$splitAUPR),2)*100 round(mean(perf$splitAccuracy),2)*100 Notice that although the AUROC is near perfect, the accuracy is lower, at around 86%. It is important to consider several measures of predictor performance to understand the behaviour of the predictor. Let us now look at the confusion matrix: Lets examine our confusion matrix: confMat &lt;- confusionMatrix(model_full) We see that the predictor performs perfectly at classifying Luminal A tumours but does worse at classifying the residual, mainly because it often classifies other tumours as Luminal A! Particularly when there is class imbalance, i.e.one class has several-fold the number of samples than the other, predictors can achieve a baseline high accuracy by cheating and simply predicting all samples as being of the dominating label. e.g.if you have 99:1 class imbalance of two classes A and B, the predictor can achieve 99% accuracy simply by calling all samples of type A! In practice, class imbalance should be handled using suitable performance evaluation metrics and sampling proportionally for training/test sets. We indeed have a class imbalance in this dataset: table(colData(brca)$STATUS,useNA=&quot;always&quot;) This function returns the confusion matrix for each split, as well as the average shown in the image above: summary(confMat) Visualize top pathways in Cytoscape We will now visualize top-scoring pathways using the Cytoscape visualization EnrichmentMap. Recall from Module 8 that an EnrichmentMap is a network visualization of related gene-sets, where each node is a pathway and edges connect similar pathways. Let us say we only want to see pathways that scored in some target range for most of the trials; i.e.consistently high-scoring pathways. We quantify this by asking only for features that score [EMapMinScore,EMapMaxScore] for EMapPctPass fraction of trials. Here we ask for features scoring 7+ out of 10 for at least 70% of the train/test splits. emap &lt;- makeInputForEnrichmentMap ( model=model_full, results=results, pathwayList=pathList, EMapMinScore=7L, EMapMaxSore=10L, EMapPctPass=0.7, outDir=tempdir() ) This call will return paths to the output files, which you need to now download from AWS to your personal computer: emap netDx can directly generate EnrichmentMaps on a locally-installed version of Cytosape using RCy37. RCy3 allows programmatic control of Cytoscape from within R, so that visualizations such as EnrichmentMap can be programmatically created. This step needs a local copy of Cytoscape installed, so it wont work on the lab AWS instance. Try it on your laptop after the lab. ###plotEmap(gmtFiles[[1]],nodeAttrFiles[[1]], ### groupClusters=TRUE, hideNodeLabels=TRUE) If you wanted to look at an EnrichmentMap anyway, you can download the input files shown in the output of the emap object above by opening your web browser to: http://your-student-instance and downloading the files from there. Then build an Enrichment map using Cytoscape on your laptop as discussed earlier in the Cancer Analysis workshop. When youre done, the Enrichment Map for top pathways predictive of Luminal A status would look like this (below). The speech bubbles show pathway names within a couple top clusters. Figure 4: Lab 2: EnrichmentMap for top-scoring pathways predictive of Luminal A status. Nodes show pathways scoring 7+ out of 10 in over 70% of train/test splits. Edges connect pathways with shared genes. Yellow bubbles show pathway clusters, labelled by AutoAnnotate.8 Node fills indicate top score in 70%+ of the splits. Speech bubbles show pathways in example clusters. Optional: You can download the Cytoscape session file here to see the finished result. In practice, it can take a good portion of an hour to adjust the layout of the EnrichmentMap, and often longer to explore the contents. The automatically-generated pathway theme labels are often a reasonable first guess, but youll find youll often revise them upon closer inspection of the pathways within. We notice that the Enrichment Map identifies several pathways known to be dysregulated in Luminal A breast tumours, including estrogen receptor-mediating signaling (PLASMA_MEMBRANE_ESTROGEN_RESPONSE_SIGNALING), p38 signaling, pathways related to genomic stability and DNA damage response (ATM), cell profileration-related signaling (ErbB signaling). Thats it! Youve successfully generated a predictor using pathway-level features from gene expression and defined custom similarity metrics for clinical data. This completes our lab exercises for Module 11. sessionInfo sessionInfo() References 5. Merico, D., Isserlin, R., Stueker, O., Emili, A. &amp; Bader, G. D. Enrichment map: A network-based method for gene-set enrichment visualization and interpretation. PLoS One 5, e13984 (2010). 6. Subramanian, A. et al. Gene set enrichment analysis: A knowledge-based approach for interpreting genome-wide expression profiles. Proc. Natl. Acad. Sci. U. S. A. 102, 1554515550 (2005). 7. Gustavsen, J. A., Pai, S., Isserlin, R., Demchak, B. &amp; Pico, A. R. RCy3: Network biology using cytoscape from within R. F1000Res. 8, 1774 (2019). 8. Kucera, M., Isserlin, R., Arkhangorodsky, A. &amp; Bader, G. D. AutoAnnotate: A cytoscape app for summarizing networks with semantic annotations. F1000Res. 5, 1717 (2016). "],["references.html", "References", " References 1. Pai, S. et al. netDx: Interpretable patient classification using integrated patient similarity networks. Mol. Syst. Biol. 15, e8497 (2019). 2. Pai, S. et al. netDx: Software for building interpretable patient classifiers by multi-omic data integration using patient similarity networks. F1000Research 9, 1239 (2021). 3. Comprehensive molecular portraits of human breast tumours. Nature 490, 6170 (2012). 4. Yersal, O. &amp; Barutca, S. Biological subtypes of breast cancer: Prognostic and therapeutic implications. World J. Clin. Oncol. 5, 412424 (2014). 5. Merico, D., Isserlin, R., Stueker, O., Emili, A. &amp; Bader, G. D. Enrichment map: A network-based method for gene-set enrichment visualization and interpretation. PLoS One 5, e13984 (2010). 6. Subramanian, A. et al. Gene set enrichment analysis: A knowledge-based approach for interpreting genome-wide expression profiles. Proc. Natl. Acad. Sci. U. S. A. 102, 1554515550 (2005). 7. Gustavsen, J. A., Pai, S., Isserlin, R., Demchak, B. &amp; Pico, A. R. RCy3: Network biology using cytoscape from within R. F1000Res. 8, 1774 (2019). 8. Kucera, M., Isserlin, R., Arkhangorodsky, A. &amp; Bader, G. D. AutoAnnotate: A cytoscape app for summarizing networks with semantic annotations. F1000Res. 5, 1717 (2016). "]]

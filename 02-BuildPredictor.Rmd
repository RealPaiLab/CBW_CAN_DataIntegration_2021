# Lab 1: Build 3-way patient classifier from 4 data layers

## Intro

## Setup

```{r,eval=FALSE}
suppressWarnings(suppressMessages(require(netDx)))
```

In this example, we use curated data from The Cancer Genome Atlas, through the BioConductor `curatedTCGAData` package.

Here we load the required packages and download clinical and gene expression data.
```{r,eval=FALSE}
suppressMessages(library(curatedTCGAData))
```

Take a look at the available data without downloading any (set `dry.run=TRUE`): 
```{r,eval=FALSE}
curatedTCGAData(diseaseCode="BRCA", assays="*",dry.run=TRUE)
```

Let's download 4 kinds of data:
* gene expression (measured on XXX arrays)
* DNA methylation (XXX arrays)
* proteomic measures from XXX, and 
* miRNA sequencing 

```{r,eval=FALSE}
brca <- suppressMessages(curatedTCGAData("BRCA",
                                         c("mRNAArray","Methylation_methyl27", 
										 "RPPAArray","miRNASeqGene"),
                                         dry.run=FALSE))
```

Let's look at the `MultiAssayExperiment` object. Recall that this is a container for 

```{r,eval=FALSE}
brca
```

### MultiAssayExperiment
```{r,eval=FALSE}
summary(assays(brca))
```

Look at sample phenotype data:
```{r,eval=FALSE}
pheno <- colData(brca)
colnames(pheno)[1:20]
head(pheno[,1:5])
```

This next code block prepares the TCGA data. This includes:
* removing duplicate samples
* reformatting patient IDs (e.g. removing spaces and hyphens)
* creating an `ID` column in `colData(brca)`, which contains unique patient IDs
* creating a `STATUS` column in `colData(brca)` which contains the patient labels (i.e what we want netDx to classify).

In practice you would do this once and save the data before running netDx. This code has been moved into a supporting file, `prepare_data.R`. You can explore it after the lab to see how some things are achieved (e.g. removing duplicate samples).

```{r,eval=FALSE}
source("prepare_data.R")
brca <- prepareDataForCBW(brca)
```

Notice that we now have `ID` and `STATUS` columns in the sample metadata table:

```{r,eval=FALSE}
pheno <- colData(brca)
head(pheno[,c("ID","STATUS")])
table(pheno$STATUS,useNA="always")  # useNA lets you see 
									# unintentional missing values
```

## Design custom patient similarity networks (features)

netDx allows the user to define a custom function that takes patient data and variable groupings as input, and returns a set of patient similarity networks (PSN) as output. The user can customize what datatypes are used, how they are grouped, and what defines patient similarity for a given datatype. 

When running the predictor (next section), the user simply passes this custom function as an input variable; i.e. the `makeNetFunc` parameter when calling `buildPredictor()`.

***Note:*** While netDx provides a high degree of flexibility in achieving your design of choice, it is up to the user to ensure that the design, i.e. the similarity metric and variable groupings, is appropriate for your application. Domain knowledge is almost likely required for good design. 

netDx requires that this function take some generic parameters as input. These include:

* `dataList`: the patient data, provided as a `MultiAssayExperiment` object. Refer to the [tutorials for MultiAssayExperiment](https://bioconductor.org/packages/release/bioc/html/MultiAssayExperiment.html) to see how to construct those objects from data.
* `groupList`: sets of input data that would correspond to individual networks (e.g. genes grouped into pathways)
* `netDir`: the directory where the resulting PSN would be stored.

### dataList
**Function:** Multi-modal input data
**Format:** `MultiAssayExperiment` object. 

```{r,eval=FALSE}
summary(brca)
```

### groupList
**Function:** This object tells the predictor how to group units within a layer, to generate a PSN.
Possible choices:
* Simplest (fewest number of nets): All features go into one network ("Transcriptome","Metabolome",etc.,)
* Granular (most number of nets): The other extreme, where each measure (e.g. each gene) gets its own network. ***Warning*** We do not recommend this design unless you have done some prefiltering. This can result in really slow run times and out-of-memory errors.
* Biologically-meaningful groupings (intermediate): Group measures by user-specified sets; e.g. create one feature per pathway.

In this simple example we just create one network per datatype
```{r,eval=FALSE}
expr <- assays(brca)
groupList <- list()
for (k in 1:length(expr)) {
	cur <- expr[[k]]; nm <- names(expr)[k]
	# all measure names should be in rownames column
	groupList[[nm]] <- list(nm=rownames(cur)) 
	names(groupList[[nm]])[1] <- nm;
}
```

So the `groupList` variable has one entry per data *layer*:
```{r,eval=FALSE}
summary(groupList)
```

For example, here are the networks to be created with RNA data. Genes corresponding to pathways are to be grouped into individual network. Such a groupList would create pathway-level networks:

```{r,eval=FALSE}
names(groupList[["BRCA_mRNAArray-20160128"]])
head(groupList[["BRCA_mRNAArray-20160128"]][[1]])
```

### Define patient similarity for each network
This function is defined by the user and tells the predictor how to create networks from the provided input data.

This function requires `dataList`,`groupList`, and `netDir` as input variables. The residual `...` parameter is to pass additional variables to `makePSN_NamedMatrix()`, notably `numCores` (number of parallel jobs).


```{r, eval=FALSE}
makeNets <- function(dataList, groupList, netDir,...) {
	netList <- c() # initialize before is.null() check
	
	layerNames <- c("BRCA_miRNASeqGene-20160128",
		"BRCA_mRNAArray-20160128",
		"BRCA_RPPAArray-20160128",
		"BRCA_Methylation_methyl27-20160128")

	# Similarity defined as Pearson correlation
	for (nm in layerNames){
		if (!is.null(groupList[[nm]])){ # IMPORANT check
			netList_cur <- makePSN_NamedMatrix(dataList[[nm]],
				rownames(dataList[[nm]]),
				groupList[[nm]],
				netDir,verbose=TRUE, 
				writeProfiles=TRUE,...)
			netList <- c(netList,netList_cur)
		}

	}
	return(unlist(netList))
}

```

**Note:** `dataList` and `groupList` are generic containers that can contain whatever object the user requires to create PSN. **The custom function gives the user complete flexibility in feature design**. 

## Build predictor

Finally we call the function that runs the netDx predictor. We provide:
* patient data  (`dataList`)
* grouping rules (`groupList`)
* function to create PSN from data, includes choice of similarity metric (`makeNetFunc`)
* number of train/test splits over which to collect feature scores and average performance: `numSplits`, 
* maximum score for features in one round of feature selection  (`featScoreMax`, set to 10)
* threshold to call feature-selected networks for each train/test split (`featSelCutoff`); only features scoring this value or higher will be used to classify test patients,
* number of cores to use for parallel processing (`numCores`).

The call below runs 2 train/test splits, to be able to run fast. 
Within each split, it:

* splits data into train/test using the default split of 80:20
* score2 networks between 0 to 2 (i.e. `featScoreMax=2`)
* uses networks that score >=1 out of 2 (`featSelCutoff`) to classify test samples for that split.

These are unrealistically low values set so the example will run fast. In practice a good starting point is `featScoreMax=10`, `featSelCutoff=9` and `numSplits=100`, but these parameters depend on the sample sizes in the dataset and heterogeneity of the samples.
 
```{r,eval=FALSE}
set.seed(42) # make results reproducible
outDir <- paste(tempdir(),randAlphanumString(),
	"pred_output",sep=getFileSep())
## set keepAllData=TRUE to not delete at the end of the predictor run.
## This can be useful for debugging.
model <- buildPredictor(
      dataList=brca,		## your data
	  groupList=groupList,	## grouping strategy
      makeNetFunc=makeNets,	## function to build PSNs
      outDir=outDir, 		## output directory
	  trainProp=0.8,		## pct of samples to use to train model in
	  						## each split
      numSplits=2L,			## number of train/test splits
	  featSelCutoff=1L,		## threshold for calling something
	  						## feature-selected
	  featScoreMax=2L,		## max score for feature selection
      numCores=4L,			## set higher for parallelizing
	  debugMode=FALSE,
	  keepAllData=FALSE,
      logging="none"
	  )
```

## Examine output
The results are stored in the list object returned by the `buildPredictor()` call.
This list contains:

* `inputNets`: all input networks that the model started with. 
* `Split<i>`: a list with results for each train-test split
  * `predictions`: real and predicted labels for test patients
  * `accuracy`: percent accuracy of predictions
  * `featureScores`: feature scores for each label (list with `g` entries, where `g` is number of patient labels). Each entry contains the feature selection scores for the corresponding label.
  * `featureSelected`: vector of features that pass feature selection. List of length `g`, with one entry per label.

```{r,eval=FALSE}
summary(out)
summary(out$Split1)
```

### Get model results
Now we get model output, including performance for various train/test splits and consistently high-scoring features.  `helper.R` contains convenience functions to do this, which will be integrated into upcoming versions of netDx. 

In the function below, we define top-scoring features as those which score at least 2 in at least half of the train/test splits

```{r,eval=FALSE}
source("helper.R")
results <- getResults(brca,model,featureSelCutoff=2L,
	featureSelPct=0.5)
```

`results` contains `performance`, `selectedFeatures` for each patient label, and the table of feature `scores`.

```{r,eval=FALSE}
summary(results)
```

Look at the performance:
```{r,eval=FALSE}
results$performance
```

Look at feature scores for all labels, across all train-test splits:
```{r, eval=FALSE}
results$featureScores
```

And here are selected features, which are those scoring 2 out of 2 in at least half of the splits. This threshold is simply for illustration. In practice we would run at least 10 train/test splits (ideally 100+), and look for features that score 7+ out of 10 in >70% splits.

```{r,eval=FALSE}
r$selectedFeatures
```

We finally get the integrated PSN and visualize it using a tSNE plot:

```{r,fig.width=8,fig.height=8, eval=FALSE}
psn <- getPSN(brca,groupList,makeNets,results$selectedFeatures)

tsne <- tSNEPlotter(
	psn$patientSimNetwork_unpruned, 
	colData(brca)
	)
```

## Conclusion

Congratulations! You have successfully classified three types of tumours by integrating four different -omic layers (transcriptomic, methylomic,proteomic and miRNA). 

But these features aren't really interpretable. Let's change that with our next tutorial.

Best practices side note: We end this tutorial with a call to `sessionInfo()` which prints the complete environment information for your R session. This is standard output that should be reported to R package managers when you write in with a question, particularly if reporting an error or bug. Sometimes a particular underlying dependency package may be the cause of an error, or you may need to upgrade to a newer version of the package. By including this info in an email, you will allow the other person to better solve your issue. 

## sessionInfo
```{r}
sessionInfo()
```
